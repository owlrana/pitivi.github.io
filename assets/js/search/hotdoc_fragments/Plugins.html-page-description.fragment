fragment_downloaded_cb({"url": "Plugins.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"Plugins.md\">\n<h1 id=\"plugins\">Plugins</h1>\n<p>The PiTiVi plugin system will help keep the core to a minimum codebase\nrequired for normal editing. The plugins will add various kind of\nfunctionnalities/interfaces for new features, special hardwares, online\nservices, ....</p>\n<h1 id=\"use-cases-for-plugins\">Use Cases for Plugins</h1>\n<p>This is a list of use cases for plugins so we can figure out what are\nthe various categories of plugins we will need.</p>\n<ul>\n<li>Istanbul controller : To be able to do screen-grabs that can then be\nedited within pitivi</li>\n<li>YouTube uploader : uploading projects to YouTube</li>\n<li>3rd party effects : provides higher-level effects re-using existing\nGStreamer elements. (optional) can provide a specific UI.</li>\n<li>UI-only plugins : provide a different user interface to manipulate\nthe timeline for specific tasks (compositing-specific view for\nexample)</li>\n<li>Specific hardware integration</li>\n<li>image sequence loader : So you can load a sequence of image files\nand use that as a source in the timeline.</li>\n<li><strong>Put your ideas here...</strong></li>\n</ul>\n<h1 id=\"case-studies\">Case Studies</h1>\n<p>Here we analyze some pluggable architecture implemented by other\nopensource projects in order to focus their strength/weak points in\nrelation to pitivi's needs. The list here does not pretend at all to be\nexaustive but is only meant to provide a cheap guided tour of the\nneighbourhood.</p>\n<h2 id=\"the-deluge-way\">The Deluge way</h2>\n<p>Deluge is a bittorrent client written in python+gtk\n(http://www.deluge-torrent.org), it provides one of the most simple\nimplementation of a pluggable architecture:</p>\n<p>Plugins are stored in subdirectories of the ./plugin path. Each\nsubdirectory takes the name of the contained plugin. Each plugin should\nat least provide an __init__.py file which defines the custom\nnamespace and provides the access points for the plugin.</p>\n<p>Inside the __init__.py are stored:</p>\n<ul>\n<li>Description fields (plugin's name, author, version and description)</li>\n<li>deluge_init() function is called to initialize the plugin</li>\n<li>enable() function is called when the user enables the plugin</li>\n</ul>\n<p>The plugin manager scans the plugin directory for new items and when a\nplugin is found, it imports the namespace into the list of plugins and\ncalls the deluge_init() function to initialize the plugin.</p>\n<p>This implementation has the major advantage of being lightweight.</p>\n<p>It does not create a class hierarchy for plugins: this can be both an\nadvantage and an handicap since changes in the common base plugin class\nwould potentially break plugin's compatibility but having a common\nancestor can simplify usual operation by defining them inside the\nancestor.</p>\n<p>It is not possible to categorize plugins, even if a simple \u201ccategory\u201d\nfield inside the __init__.py would be enough.</p>\n<p>This plugin architecture is useful for extending the application with\nfunctionality not considered in the core objects, since the plugin has\nfull control over the application and can thus extend any aspect of the\nhost.</p>\n<h2 id=\"the-jokosher-way\">The Jokosher way</h2>\n<p>Jokosher is an audio production software that uses python+gtk+gstreamer\n(http://www.jokosher.org)</p>\n<p>Its pluggable architecture places plugins into the ./extensions\ndirectory. Plugins can be stored as source .py files or packed into\npython eggs.</p>\n<p>Extension API are provided for inserting menu items inside the main\njokosher menu, as well as functions to control playback, instruments and\nto add new output formats.</p>\n<p>Plugin preferences are stored in the ./extension-config path, with one\nconfig file for each plugin named as the plugin itself. Preferences are\nserialized by pickle into a dictionary of objects; standard methods to\nstore and retrieve keys from the dictionary are available to the plugin\nwriter.</p>\n<p>The plugin manager install/remove plugins taking care of possible\nconflicts, it also manages the loading/unloading/configuration processes\nfor each plugin, ensuring each plugin is loaded only once (plugins are\ntreated as singletons).</p>\n<p>Each plugin must contain:</p>\n<ul>\n<li>some descriptive fields identifying the name, description and\nversion</li>\n<li>startup(api) function is called when the plugin is activated,\npassing the whole API set to the the plugin.</li>\n<li>shutdown() function is called when the plugin is deactivated, it\ntakes care of the cleanings.</li>\n</ul>\n<p>This approach defines a clear set of API that the plugin can use as\npreferred way to interact with the main application, API are pushed into\nthe plugin when it is activated and a reference to them is usually kept\ninside the plugin though all its lifetime.</p>\n<p>API for UI integration allow to insert new menu items, leaving to the\nplugin the responsability to remove the inserted items when it is\nunloaded. The same logic is applied when additional output formats are\nprovided by the plugin, those must be removed from available output\nformat by the plugin itself when it is deactivated.</p>\n<p>Strength points of the Jokosher approach are a well designed and\nlightweight plugin manager; the possiblity to store plugins in python\neggs that simplifies a lot the deployment of new plugins; a clean set of\nAPI the plugin can use to interact with the host application; the\npossibility to add new output formats; the possibility to save plugin's\npreferences without having the plugin care about serialization\nprocedures.</p>\n<p>Weak points of this architecture are a limited UI integration beccause\nplugins wich uses only the API can insert menu items only under the\n\u201cplugin\u201d submenu; the creation of a preferences file for each plugin\navailable could lead to a pollution of config files; leaving to plugins\nthe duty of removing UI enhancements they inserted could lead to waste\nof memory if the plugin writer does not make a good job, a defaulf\napproach for cleaning would be preferrable.</p>\n<h2 id=\"the-trac-way\">The Trac way</h2>\n<p>Trac is an enhanced wiki and issue tracking system for software\ndevelopment projects (http://trac.edgewall.org/), it has a consistent\npluggable architecture that it strikingly rensembles the one of the\nEclipse framework:</p>\n<p>The main application exposes some entry points where plugin can plug\ninto. each entry point is characterized by a contract that both the\nplugin and the main application must subscrive in order to interact;\nthis contract takes the concrete form of an interface declared by the\nmain application and implemented by the plugin.</p>\n<p>Each plugin can implement multiple interfaces, in this way it extends\nmultiple aspects of the main application.</p>\n<p>Each entry point can be plugged by multiple plugins, thus the same\nfeature of the main application can be extended in multiple ways.</p>\n<p>Plugins can expose entry points themself, allowing them to be extended\nby other plugins.</p>\n<p>Trac plugins inherits from the \u201cComponent\u201d class and are deployed as\npython eggs.</p>\n<p>The whole application is designed to be modular and plugins can also be\ncreated to replace built-in components.</p>\n<p>Technically, the most of the work is done in the core.py file which\ndeclares the following structures:</p>\n<ul>\n<li>Interface class, defines the ancestor of all interfaces implemented\nby plugins using the implements() function</li>\n<li>ExtensionPoint class, defines each single extension point slot,\ncharacterized by an Interface that every component who wants to plug\nmust conform.</li>\n<li>Component class, defines the generical component boundled to an\nexinsing component manager</li>\n<li>ComponentManager class, manages all the components available to the\napplication, switching them on/off and taking care each component is\na singleton.</li>\n</ul>\n<p>Trac approach intruces a simple implementation for interfaces in python,\nan example code of how this architecture is used for creating plugins is\nreported in the following example (taken from Trac documentation):</p>\n<p><code>from\u00a0trac.core\u00a0import\u00a0*</code></p>\n<p><code>class\u00a0ITodoObserver(Interface):</code></p>\n<p><code>\u00a0\u00a0\u00a0\u00a0def\u00a0todo_added(name,\u00a0description):</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0\u00a0</code>\u201c\u201c\u201c<code>Called`` ``when`` ``a`` ``to-do`` ``item`` ``is`` ``added.</code>\u201d\u201d\u201d</p>\n<p><code>class\u00a0TodoList(Component):</code></p>\n<p><code>\u00a0\u00a0\u00a0\u00a0observers\u00a0=\u00a0ExtensionPoint(ITodoObserver)</code></p>\n<p><code>\u00a0\u00a0\u00a0\u00a0def\u00a0__init__(self):</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.todos\u00a0=\u00a0{}</code></p>\n<p><code>\u00a0\u00a0\u00a0\u00a0def\u00a0add(self,\u00a0name,\u00a0description):</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assert\u00a0not\u00a0name\u00a0in\u00a0self.todos,\u00a0'To-do\u00a0already\u00a0in\u00a0list'</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0self.todos[name]\u00a0=\u00a0description</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for\u00a0observer\u00a0in\u00a0self.observers:</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0observer.todo_added(name,\u00a0description)</code></p>\n<p><code>class\u00a0TodoPrinter(Component):</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0implements(ITodoObserver)</code></p>\n<p><code>\u00a0\u00a0\u00a0\u00a0def\u00a0todo_added(self,\u00a0name,\u00a0description):</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print\u00a0'TODO:',\u00a0name</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0print\u00a0'\u00a0\u00a0\u00a0\u00a0\u00a0',\u00a0description</code></p>\n<p>ITodoObserver interface provides a todo_added() callback to trigger\nplugin's functionalities.</p>\n<p>The class TodoList is declared as expandable by declaring an extension\npoint, used by plugins that implements the ITodoObserver interface.</p>\n<p>Finally an example plugin TodoPrinter is written that extends the\nTodoList by implementing the interface ITodoObserver via the\nimplements() function.</p>\n<h2 id=\"the-zope-way\">The Zope way</h2>\n<p>Since version 3.0 the CMS engine Zope (http://www.zope.org) introduced a\nfull fledged interface implementation in python, as core system for its\npluggable architecture.</p>\n<p>In python the concept of interfaces, intended as a formal way to define\nrelationships between items, does not yet exist; instead duck typing is\nthe generally utilized way, so if an object hasattr(foo, 'bar') then\nfoo.bar(), but this approach goes so far, since it is not possible to\ndetermine if an attribute is callable or has constrains to its possible\nvalues.</p>\n<p>In fact plugin developers must rely over documentation to check what\nmethods their classes have to provide to implement a certain feature,\nand this approach is very prone to broke plugins compatibility if\ndocumentation is not kept perfectly synchronized with the code.</p>\n<p>Zope interfaces are designed to be applied not only to classes, but also\nto modules, objects and functions, since they follow the golden rule\nthat \u201cspecification should make no assumption about implementation\u201d;\nthis approach leaves complete freedom to the plugin developer to\norganize its code in the way it prefers, as long the intefrace\nrequirements are fullfilled; in this way duck typing gets formalized\nwithout adding a big overhead.</p>\n<p><code>from\u00a0zope.interface\u00a0import\u00a0Interface,\u00a0implements,\u00a0\u00a0providedBy</code></p>\n<p><code>class\u00a0ISing(Interface):</code><br>\n<code>\u00a0\u00a0\u00a0def\u00a0sing():</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0</code>\u201c<code>\"</code>\u201d<code>\u00a0Returns\u00a0a\u00a0melody\u00a0</code>\u201c<code>\"</code>\u201d</p>\n<p><code>class\u00a0Sinatra(object):</code><br>\n<code>\u00a0\u00a0\u00a0implements(ISing)</code></p>\n<p><code>\u00a0\u00a0\u00a0def\u00a0sing(self):</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\u00a0</code>\u201c<code>In`` ``singing`` ``in`` ``the`` ``rain...</code>\u201d</p>\n<p><code>frank\u00a0=\u00a0Sinatra()</code><br>\n<code>ISing.providedBy(frank)\u00a0\u00a0\u00a0\u00a0&lt;--\u00a0True</code></p>\n<p>Interfaces fully supports inheritance from other interfaces (with the\nsecurity check that children's methods conforms to ancestor's one if\noverridden), implementer of an interface hierarchy can limit the\nimplentation only to a certain child interface in the lineage; the\nstatus of interface implementer can be attached at runtime to items that\ndo not explicitely implemented the interface in their definition; as\nwell the implementer status can be removed from an item at runtime\n(useful for example in containers that implement an interface by\ndelegating implementation to contained objects).</p>\n<p>The other big feature of Zope interfaces is that they can be used to\ncreate adapters in a very efficient way, providing also a centralized\nregistry for adapters.</p>\n<h2 id=\"considerations\">Considerations</h2>\n<p>These case studies exemplify two different approaches for extending the\nhost application:</p>\n<p>In the first two cases (Deluge and Jokosher) the host application\nbasically defines a plugin manager that takes care of activating and\ndeactivating plugins; when activated, the plugin is allowed to access\nthe core objects and modify the application as it wants.</p>\n<p>This approach has the advantage to leave complete freedom to plugins at\nthe cost of anarchy, since there isn't a standardized way for the plugin\nto interact with the host application. Jokosher tries to overcome this\nsituation by defining some API that can be optionally used by plugins to\naccomplish common tasks. The other big advantage is that plugins can be\ncreated to extend aspect of the application not considered originally by\nthe author to be extendable.</p>\n<p>In the third case study (Trac), as opposite, plugins can only extend\nspecific aspects of the host application defined as extension points,\nwhose declare a clear contract the plugin must subscrive if it wants to\nextend the host application.</p>\n<p>This approach enforces a neat definition of rights and duties for the\npartiecipants to the extension process at the cost of some freedom. In\nthis way plugins do not \u201cput\u201d their features into the application, but\n\u201coffer\u201d instead some extended features the application can use.</p>\n<p>The last case study (Zope) further improves the concept of interfaces,\nadding the possibility to define attributes/constrains inside\ninterfaces, providing functions to check interface\nimplementation/definition, adding a complete facility to provide\nadapters; all this is done in the pythonic way of leaving the developer\nthe most freedom.</p>\n<p>The main advantage of using interfaces over class inheritance is that\nthe former defines relationships between items and keeps the system\nhigly decoupled, while the latter constrains thee partecipants to a gree\nan \u201cis a\u201d relationship, thus creating strong coupling between classes.</p>\n<h1 id=\"pluggable-architecture-proposal\">Pluggable architecture proposal</h1>\n<p>In the light of needed use cases and analyzed case studies the following\nhybrid pluggable architecture is proposed for Pitivi.</p>\n<h2 id=\"nomeclature\">Nomeclature</h2>\n<p>From here on, we will use the term \u201cextension point\u201d to define an aspect\nof the main application which can be extended by plugins. In respect to\nextension point we'll define \u201chost\u201d the component (usually pitivi but\nalso plugins can be extended) that exposes the extension point, and\n\u201cextender\u201d the component that plugs into the extension point in order to\nprovide additional features to the host component. Every extension point\nis characterized by a contract that both the parts must subscrive in\norder to interact.</p>\n<h2 id=\"plugin-deployment\">Plugin deployment</h2>\n<p>Since simple plugins may consist of a single python file, while complex\nplugins may comprise glade interfaces, code written in other languages,\ngraphics etc.. etc.. then plugins needs to be packed.</p>\n<p>A convenient method is to take advantage of python eggs\n(http://peak.telecommunity.com/DevCenter/PythonEggs) and create an .egg\nfile for each plugin. Eggs are similar to java's jar files, they make\nvery simple the shipping and installation of new plugins since all you\nneed is to drag the .egg file inside the ./plugins directory. Eggs also\nships a standard method for exposing plugin's entry points and\ndependancies, making easy to allow cooperation/subordination among\nplugins.</p>\n<p>we can expect pitivi to be shipped with some default plugins available\nfor all the users and meant to be uninstalled by the system\nadministrator only; while it is also auspicable to let users install\ncustom plugins and encourage them in writing new ones.</p>\n<p>Default plugins could be placed inside the pitivi installation path (i.e\n/usr/local/pitivi/plugins), these plugins are usually installed by the\nlinux distribution facility and only users with root privileges can\nmodify them directly.</p>\n<p>User plugins could be placed inside the user home directory (i.e. in\n/home/my_user/.pitivi/plugins) and can be installed/deleted/modified by\nthe user.</p>\n<p>Pitivi should check for both the locations when searching for available\nplugins, and should use the user home to store plugin configuration\nparameters (i.e /home/my_user/.pitivi/plugin-settings).</p>\n<h2 id=\"the-extension-act\">The extension act</h2>\n<p>The relationship that exists between extension points and plugins is\nschematized in this cartoon:</p>\n<p><img src=\"images/Extension_schema.png\" alt=\"\"></p>\n<ol>\n<li>Each plugin may act as extender and as host by exposing extension\npoint itself.</li>\n<li>Each host may have many extension points.</li>\n<li>Each extension point may be extended by multiple extenders.</li>\n<li>Each extender may extend multiple extension points.</li>\n</ol>\n<p>In order to plug into the extension point the extender component must\nconform a protocol declared by the host component; this intefrace\nspecifies function signatures for the duties that host component is\nplanned to demand to plugin, like callbacks for occurred events, widgets\nto integrate into the user interface or implementation of common\noperations over new file formats.</p>\n<p>Each extension point should be able to keep a list of extenders plugged\nin, providing to the host component a convenient way for trasversing\nextenders.</p>\n<h2 id=\"direct-core-objects-access\">Direct core objects access</h2>\n<p>For those plugin which wants to extend aspects of the application not\nexposing extension points, core objects of the host application can be\nmanipulated directly by the plugin writer. Since in python classes does\nnot encforce information hiding concepts, the plugin writer can easily\naccess them and inject the new features.</p>\n<p>In order to allow the plugin this alternative extension approach, the\nplugin writer will insert new features when the plugin is activated by\nthe plugin manager, and provide a complete cleaning of plugged features\nwhen the plugin is deactivated.</p>\n<h2 id=\"plugin-manager\">Plugin manager</h2>\n<p>The plugin manager is the orchestra director, its duties comprise:</p>\n<ol>\n<li>Keep track of available plugins</li>\n<li>Install/Remove plugins</li>\n<li>Activate/deactivate plugins</li>\n<li>Provide facilities to store and retrieve plugin's preferences</li>\n<li>Retrieve plugins from the pools on a category search criterium</li>\n<li>Resolve versioning conflicts and incompatibilities among plugins</li>\n</ol>\n<h1 id=\"use-cases-for-plugin-manager\">Use cases for plugin manager</h1>\n<h2 id=\"install-a-new-plugin\">Install a new plugin</h2>\n<p>For a generic plugin the user:</p>\n<ol>\n<li>Open the plugins list window</li>\n<li>Drags&amp;drop the new plugin's package inside the list of plugins</li>\n</ol>\n<p>For an effect/transition the user:</p>\n<ol>\n<li>Selects the effects list</li>\n<li>Drag&amp;drop the effect plugin inside the list of available effects</li>\n</ol>\n<p>The plugin manager backend:</p>\n<ol>\n<li>Catch the drop of items inside the plugin list</li>\n<li>Check the item dropped is really a plugin compatible with the\ncurrent version of the application</li>\n<li>Check if the plugin requires other plugins to be installed, stop if\nthose are not present</li>\n<li>Copy the package inside the user plugin directory</li>\n<li>register the plugin among the pool of available plugins</li>\n<li>If there are plugins requiring the installed one to work, make them\nactivable by the user</li>\n<li>Update the plugin/effect/transition list</li>\n</ol>\n<h2 id=\"uninstall-a-custom-plugin\">Uninstall a custom plugin</h2>\n<p>The user:</p>\n<ol>\n<li>Drag&amp;drop the plugin from the list of plugins to the trash</li>\n</ol>\n<p>The plugin manager backend:</p>\n<ol>\n<li>Catch the drop of a plugin from the list to the trash</li>\n<li>Check for plugins that depends upon this one, and ask the user if he\nwants to cancel the operation or proceed anyway</li>\n<li>Deactivate the plugin if active</li>\n<li>Unregister the plugin from the pool of available plugins</li>\n<li>Remove the plugin package</li>\n<li>Disable plugins whose require the trashed plugin to be activated</li>\n<li>Make plugin whose require the trashed plugin unactivable by the user</li>\n<li>Update the plugin/effect/transition list</li>\n</ol>\n<h2 id=\"upgrade-an-existent-plugin\">Upgrade an existent plugin</h2>\n<p>The user:</p>\n<ol>\n<li>Drag&amp;drop the new version of the plugin into the list of plugins</li>\n</ol>\n<p>The plugin manager:</p>\n<ol>\n<li>Check the plugin pool for duplicates of the plugin to be installed</li>\n<li>Ensure the verion of the dropped plugin is newer than the current's,\notherwise prompt the user for confirmation</li>\n<li>Remove the old plugin, preserving configuration items</li>\n<li>Install the new plugin</li>\n</ol>\n<h2 id=\"configure-a-plugin\">Configure a plugin</h2>\n<p>The user:</p>\n<ol>\n<li>Open the plugin manager window</li>\n<li>Select the plugin to configure</li>\n<li>Press the \u201cConfigure\u201d button to show the configuration dialog.</li>\n</ol>\n<p>The plugin manager:</p>\n<ol>\n<li>Ask the plugin for the configuration dialog.</li>\n<li>Retrieve from the plugin configuration file the dictionary of config\nvalues belonging to the plugin</li>\n<li>Pass the plugin the dictionary</li>\n<li>The plugin updates the dictionary passed by the plugin manager</li>\n<li>Save the dictionary in the file containing plugin configuration</li>\n</ol>\n<h2 id=\"enabledisable-a-plugin\">Enable/Disable a plugin</h2>\n<p>The user:</p>\n<ol>\n<li>Open the plugin manager window</li>\n<li>Check/Unckeck the plugin</li>\n</ol>\n<p>The plugin manager:</p>\n<ol>\n<li>Load/unload the plugin</li>\n<li>Refresh the user interface if plugin extended it</li>\n</ol>\n<h1 id=\"design\">Design</h1>\n<h2 id=\"ui-integration\">UI integration</h2>\n<p>Extending the user interface could be achieved in basically two ways in\nGTK:</p>\n<p>The first is writing custom code to integrate new widgets provided by\nthe plugin into the current user interface design.</p>\n<p>The second way is taking advantage of the UImanager component provided\nby gtk, this facility allow the developer to define UI widgets as xml\nthen the UImanager can be told to merge the xml code into the existing\nGUI. Even thought this approach requires the plugin writer to learn\nUImanager xml syntax, the process clearly separate the UI creation part\nfrom the definition of actions triggered by the new UI piece, so it'll\nbe preferred to the former approach when possible.</p>\n<p>Despite of the type of widget integrated in the main user interface the\nfollowing interface definitions will provide methods with a \u201cUI\u201d suffix\nmeant to provide to the UImanager the xml code to integrate inside the\nmain user interface, and other methods with the suffix \u201cAction\u201d meant to\nprovide to the main application actions to bind to the main UI widgets.</p>\n<p>Plugins must conform to the following protocol if they want to extend\npitivi UI, in change pitivi is obliged to integrate the widgets provided\nby plugins in the way plugins define, with the freedom to choose when\nit's time to integrate them (usually when the main user interface is\nbuilt at application startup or when user choose to activate the\nplugin).</p>\n<h2 id=\"menu-toolbar-integration\">Menu / Toolbar integration</h2>\n<p>Placing a menu item or a tool button is the simplest way a plugin can\ninteract with the user, the following interfaces provide convenient ways\nfor the plugin to integrate widgets in the main user interface:</p>\n<p>Class IMenuProvider(Interface):</p>\n<p><code>\u00a0\u00a0\u00a0def\u00a0getUI():</code><br>\n<code>\u00a0\u00a0\u00a0</code>\u201c<code>\"</code>\u201d<code>\u00a0Return\u00a0the\u00a0xml\u00a0code\u00a0defining\u00a0the\u00a0user\u00a0interface\u00a0enhancement\u00a0</code>\u201c<code>\"</code>\u201d<br>\n<code>\u00a0\u00a0\u00a0def\u00a0getActions():</code><br>\n<code>\u00a0\u00a0\u00a0</code>\u201c<code>\"</code>\u201d<code>\u00a0Return\u00a0the\u00a0list\u00a0of\u00a0actions\u00a0triggered\u00a0by\u00a0new\u00a0menuitems\u00a0</code>\u201c<code>\"</code>\u201d</p>\n<h2 id=\"additional-source-providers\">Additional source providers</h2>\n<p>This kind of plugins provides items user can drag into the timeline such\nas videoclips, effects, transitions. Pitivi inserts a new tab in the\nsources notebook displayed in the top-left portion of the main window.\nPlugins that want to be source providers must implement the following\ninterface:</p>\n<p>Class ISourceProvider(Interface):</p>\n<p><code>\u00a0\u00a0\u00a0def\u00a0getName():</code><br>\n<code>\u00a0\u00a0\u00a0</code>\u201c<code>\"</code>\u201d<code>\u00a0Return\u00a0the\u00a0name\u00a0to\u00a0be\u00a0displayed\u00a0in\u00a0the\u00a0notebook\u00a0tab\u00a0title\u00a0</code>\u201c<code>\"</code>\u201d<br>\n<code>\u00a0\u00a0\u00a0def\u00a0getWidget():</code><br>\n<code>\u00a0\u00a0\u00a0</code>\u201c<code>\"</code>\u201d<code>\u00a0Return\u00a0the\u00a0source\u00a0view\u00a0widget,\u00a0usually\u00a0a\u00a0gtk\u00a0box\u00a0</code>\u201c<code>\"</code>\u201d<br>\n<code>\u00a0\u00a0\u00a0def\u00a0getCallbacks():</code><br>\n<code>\u00a0\u00a0\u00a0</code>\u201c<code>\"</code>\u201d<code>\u00a0Return\u00a0a\u00a0tuple\u00a0of\u00a0(cb_name,\u00a0signal_name)\u00a0in\u00a0the\u00a0order\u00a0they\u00a0must\u00a0be\u00a0connected\u00a0</code>\u201c<code>\"</code>\u201d</p>\n<p>Note on signals handling: the plugin may provide callbacks to observe\napplication signals, they're retrieved from the plugin with the\ngetCallbacks() method, the returned tuple is coonnected to host\napplication signals in the order specified by the plugin, and\ndisconnected in reverse order when the plugin is deactivated.</p>\n<h2 id=\"recording-devices\">Recording devices</h2>\n<p>Recording devices such as webcams, microphones but also unconventional\nitems like screencast share the same requirements to be used by pitivi:</p>\n<p>Class IRecordingDevice(Interface):</p>\n<p><code>\u00a0\u00a0\u00a0__gsignals__\u00a0=</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0</code>\u201c<code>recording-started</code>\u201d<code>:\u00a0(gobject.SIGNAL_RUN_LAST,\u00a0gobject.TYPE_VOID,\u00a0()),</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0</code>\u201c<code>recording-finished</code>\u201d<code>:\u00a0(gobject.SIGNAL_RUN_LAST,\u00a0gobject.TYPE_PYOBJECT,\u00a0())</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0</code>\u201c<code>\"</code>\u201d<code>\u00a0recording-started\u00a0informs\u00a0observers\u00a0the\u00a0device\u00a0started\u00a0recording.</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0recording-finished\u00a0signals\u00a0the\u00a0main\u00a0application\u00a0that\u00a0a\u00a0new\u00a0clip\u00a0is\u00a0produced\u00a0by\u00a0the\u00a0device,</code><br>\n<code>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0the\u00a0clip\u00a0uri\u00a0is\u00a0returned\u00a0by\u00a0the\u00a0signal\u00a0in\u00a0order\u00a0to\u00a0be\u00a0added\u00a0among\u00a0sources\u00a0</code>\u201c<code>\"</code>\u201d<br>\n<code>\u00a0\u00a0\u00a0def\u00a0getName():</code><br>\n<code>\u00a0\u00a0\u00a0</code>\u201c<code>\"</code>\u201d<code>\u00a0Return\u00a0the\u00a0name\u00a0of\u00a0the\u00a0device\u00a0</code>\u201c<code>\"</code>\u201d<br>\n<code>\u00a0\u00a0\u00a0def\u00a0hasVideo():</code><br>\n<code>\u00a0\u00a0\u00a0</code>\u201c<code>\"</code>\u201d<code>\u00a0Return\u00a0true\u00a0if\u00a0device\u00a0can\u00a0provide\u00a0video\u00a0</code>\u201c<code>\"</code>\u201d<br>\n<code>\u00a0\u00a0\u00a0def\u00a0hasAudio():</code><br>\n<code>\u00a0\u00a0\u00a0</code>\u201c<code>\"</code>\u201d<code>\u00a0Return\u00a0true\u00a0if\u00a0device\u00a0can\u00a0provide\u00a0audio\u00a0</code>\u201c<code>\"</code>\u201d<br>\n<code>\u00a0\u00a0\u00a0def\u00a0record():</code><br>\n<code>\u00a0\u00a0\u00a0</code>\u201c<code>\"</code>\u201d<code>\u00a0Start\u00a0recording\u00a0</code>\u201c<code>\"</code>\u201d<br>\n<code>\u00a0\u00a0\u00a0def\u00a0stop():</code><br>\n<code>\u00a0\u00a0\u00a0</code>\u201c<code>\"</code>\u201d<code>\u00a0Stop\u00a0recording\u00a0</code>\u201c<code>\"</code>\u201d<br>\n<code>\u00a0\u00a0\u00a0def\u00a0isRecording():</code><br>\n<code>\u00a0\u00a0\u00a0</code>\u201c<code>\"</code>\u201d<code>\u00a0Returns\u00a0true\u00a0if\u00a0the\u00a0defice\u00a0is\u00a0currently\u00a0recording\u00a0</code>\u201c<code>\"</code>\u201d</p>\n<h2 id=\"effectstransitions\">Effects/Transitions</h2>\n<p>This kind of items represent an exception to the general concept of\nplugin, which are usually meant to be singletons by definition (only a\nsingle object for each plugin is created by the application), since\nthey're made to be applied more than one time over the timeline.</p>\n<p>Effects/Transitions are collected and exposed to the user as a list,\ngrouped into functional categories. This task will be accomplished by a\nspecialized SourceProvider plugin called Effect(Transition)Provider,\nexposing entry points where Effects can be inserted. The Provider takes\nalso care of creating a new effect object every time the user drags the\neffect to the timeline, thus implementing the Factory design pattern.</p>\n<p>Every Effect object life-cycle starts in the moment the user drags it\ninto the timeline and ends when its is removed, during its lifetime the\nobject stores its custom preferencies in memory, while default\npreferences are stored in the same way of preferences of other plugins.</p>\n<p>Detailed discussion of Effects/Transitions architecture will be\ndiscussed in a separate design document.</p>\n<h1 id=\"links\">Links</h1>\n<p>Various links for inspiration...</p>\n<h2 id=\"other-python-plugin-systems\">Other python plugin systems</h2>\n<ul>\n<li><a href=\"http://trac.edgewall.org/wiki/TracDev/ComponentArchitecture\">http://trac.edgewall.org/wiki/TracDev/ComponentArchitecture</a></li>\n<li><a href=\"http://trac-hacks.org/wiki/EggCookingTutorial/BasicEggCooking\">http://trac-hacks.org/wiki/EggCookingTutorial/BasicEggCooking</a></li>\n<li><a href=\"http://live.gnome.org/Gedit/PythonPluginHowTo\">http://live.gnome.org/Gedit/PythonPluginHowTo</a></li>\n<li><a href=\"http://jokosher.python-hosting.com/wiki/ExtensionSystem\">http://jokosher.python-hosting.com/wiki/ExtensionSystem</a></li>\n<li><a href=\"http://twistedmatrix.com/projects/core/documentation/howto/plugin.html\">http://twistedmatrix.com/projects/core/documentation/howto/plugin.html</a></li>\n<li><a href=\"http://termie.pbwiki.com/SprinklesPy\">http://termie.pbwiki.com/SprinklesPy</a></li>\n<li><a href=\"http://docs.turbogears.org/1.0/TemplatePlugins\">http://docs.turbogears.org/1.0/TemplatePlugins</a></li>\n<li><a href=\"http://www.zope.org\">http://www.zope.org</a></li>\n</ul>\n<h2 id=\"other-nonpython-plugin-systems\">Other non-python plugin systems</h2>\n<ul>\n<li><a href=\"http://www.eclipse.org/articles/Article-Plug-in-architecture/plugin_architecture.html\">http://www.eclipse.org/articles/Article-Plug-in-architecture/plugin_architecture.html</a></li>\n<li><a href=\"http://www.codeproject.com/csharp/C__Plugin_Architecture.asp\">http://www.codeproject.com/csharp/C__Plugin_Architecture.asp</a></li>\n<li><a href=\"http://www.codeproject.com/dotnet/PluginManagerClassBrk.asp\">http://www.codeproject.com/dotnet/PluginManagerClassBrk.asp</a></li>\n<li><a href=\"http://www.objectplanet.com/opinio/userguide/index.htm?page=plugin_architecture.html\">http://www.objectplanet.com/opinio/userguide/index.htm?page=plugin_architecture.html</a></li>\n<li><a href=\"http://developer.mozilla.org/en/docs/Plugin_Architecture\">http://developer.mozilla.org/en/docs/Plugin_Architecture</a></li>\n<li><a href=\"http://sync4jmozilla.sourceforge.net/Mozilla%20PIM%20Plugin%20Design%20Document.pdf\">http://sync4jmozilla.sourceforge.net/Mozilla%20PIM%20Plugin%20Design%20Document.pdf</a></li>\n<li><a href=\"http://www.gnome.org/projects/epiphany/documentation/extensions/\">http://www.gnome.org/projects/epiphany/documentation/extensions/</a></li>\n</ul>\n\n</div>\n\n\n        "});