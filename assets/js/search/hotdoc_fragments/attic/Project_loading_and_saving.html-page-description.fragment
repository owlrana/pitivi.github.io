fragment_downloaded_cb({"url": "attic/Project_loading_and_saving.html#page-description", "fragment": "File load save support in PiTiVi is seemingly simple however it has do be done properly or user experience will suffer. That is the motivation for this rather lengthy design document. \nThe following document is partially based on a patch supplied by Richard Boulton including comments and documentation strings. As the patch no longer cleanly applies I have been asked to re work it into a design document so that we can determine how best to incorporate his ideas. \nThere are states and commands giving the user a total of possible scenarios that users might encounter the initial state does not allow for two of the commands \nSave As will be treated as a special case of Save for the purposes of this document. When the Save As command is issued the user will be asked to supply a file path and the project will be saved. From then on pitivi will be editing the file pointed to by the new file path rather than the previous one. In all other respects Save As is identical to Save When a Save command is given on a new project the scenario will be identical to the Save As scenario. \nBefore saving PiTiVi checks to see if the file has been modified since the last save. When a file has changed on disk the user will be prompted to ask if it is acceptable to overwrite the file. PiTiVi will not check to see if the file has been altered except in these circumstances. \nPiTiVi only edits a single project at a time. Consequently implicit in the New Save and Save As commands is the Close Project command. Since PiTiVi s UI must always display a project a Close Project command would be identical to the New Project command. Based on this it makes sense to omit Close Project from the UI. Nevertheless it should still be considered a command that is part of this module for the sake of code reuse. \nPiTiVi should follow the established convention for large applications of keeping unsaved changes in a temporary file to minimize the potential amount of work lost due to crashes power failures accidental quits etc. After a user specifiable interval unsaved changes will be saved to a temporary file. In addition to this PiTiVi should not directly overwrite a file when saving but instead back up the original file first. \nThe high level application logic is relatively straight forward. The coding will not be due to the nature of the GObject Gtk. The logic is divided into four operations. these are New Load Save and Close The Close process is not directly operation by the user but is performed any time the current project is to be replaced. \nImage New flowchart.png Logic for creating a new project Image Load flowchart.png Logic for loading an existing project Image Save flowchart.png Logic for saving a project both Save and Save As Image Close flowchart.png Logic for closing a project \nAt the lower level the application logic will be implemented through signals and callbacks. \nThe core classes will provide public methods for initiating the operations of saving loading and creating new projects. If the core needs user input it will emit the appropriate signal passing a reference to a callback. If the UI determines that further action is necessary by the system the UI then returns control to the system by calling the callback. This means that system code could be split into two functions the public interface which initiates the action and the deferred callback which finalizes the action. \nWhile PiTiVi should make every effort to support a wide range of file formats most of these will be through external plugins. PiTiVi provides a reference implementation that uses Python s cPickle module to serialize and deserialize data in the intermediate format. \nOne goal of PiTiVis is to work work with a wide variety of project file formats. \nThe ProjectSaver class coordinates the work of saving loading and validating project data. The class works with an intermediate format which concisely represents the project. Everything contained within a project sources transitions effects compositions settings etc must implement the Serializable interface which includes the toDataFormat and fromDataFormat methods. These methods convert to and from this intermediate format. \nMultiple file formats can be supported by sub classing ProjectSaver These classes must provide dump and load methods for the file format they implement. Users of the ProjecSaver s public interface can use the methods saveToFile openFrom File listFormats and newProjectSaver. These methods are summarized in the following table \nThe following example assumes the following \nOf these sources only have been added to the timeline time stamps given in h mm ss.sss \nIn this example media duration and timeline duration correspond. This is not necessarily the case however. \nThe equivalent python data structure will look like this currently incomplete \nproject \ntimeline compositions type video sources project source start duration media start media duration project source start duration media start media duration project source start duration media start media duration \ntype audio sources project source start duration media start media duration project source start duration media start media duration \nsources \nsettings \n\nMore specifically the project is composed python dictionaries tuples and strings. It could be thought of as a tree but it is really more of a deep dictionary with several levels of nesting. Each dictionary contains a key called datatype which identifies what the kind of object it is. Optional keys are not required to exist but you must handle them if they do. \nThe project is the root of the tree. It is a dictionary with three keys \nThe composition field represents a PiTiVi timeline composition element. There is one main timeline per project but sub compositions can be represented as well. A sub composition is represented as a source dictionary whose ID field refers to a composition dictionary as defined here. This allows multiple instances of the same composition in the timeline as well as allowing only part of the composition to be used. \nThis represents a source object in a timeline. It is a dictionary containing the following keys \nThere is also the FileSource which has the same properties as above but also the following \nRepresents a list of source factories in a project. Source factories are objects which can create timeline sources. The source list is a dictionary containing \nRepresents a source factory in the project sources list. It is a dictionary containing the following keys \nProject specific settings are as follows. This section is incomplete \nA number of features are planned for future releases of PiTiVi. Handling these is currently considered optional and these specifications are subject to change. \nTransitions and effects have not yet been implemented in PiTiVi. This This represents a transition object in a timeline. It is a dictionary containing the following keys \nTODO explain how to implement a file format as a plugin \nSupport for a variety of formats will be provided by plugins which implement the ProjectSaver interface. A reference implementation exists in projectsaver.py called PickleFormat. \nWhen implementing a custom file format you should subclass ProjectSaver. Your child class should define \n"});