fragment_downloaded_cb({"url": "Pitivi-1.0/design/2008_design/2008_Plugin_Interface_development.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"2008_Plugin_Interface_development.md\">\n<h2 id=\"introduction\">Introduction</h2>\n<h3 id=\"about\">About</h3>\n<p>Pitivi's current interface, whist having a solid base is a little\nlackluster with regards to API compatibility and formality, I\n(--<a href=\"User:Gord.md\">Gord</a> 16:06, 4 August 2008 (BST)) am currently\ndeveloping a branch that aims to counter that.</p>\n<h3 id=\"development\">Development</h3>\n<p>Current development is happening on a launchpad branch (simply for ease\nof development for me) located here:\n<a href=\"https://code.edge.launchpad.net/%7Egordallott/+junk/pitivi-plugininterface_pitivi-plugininterface.md\">https://code.edge.launchpad.net/~gordallott/+junk/pitivi-plugininterface\npitivi-plugininterface</a></p>\n<h2 id=\"concept\">Concept</h2>\n<p>A plugin needs to communicate in two ways, the main application needs to\nbe able to talk to plugin code (call methods and such) and plugin code\nneeds to be able to communicate back via some sort of API, currently\npitivi handles the first problem with zope interfaces which works\nnicely, the second problem is ignored, plugins must query pitivi's\ninternal code via pitivi.instance.PiTiVi which contains the programs\ninstance.</p>\n<p>The problem with this direction is that any internal code changes will\nbreak plugin compatibility and further more it increases the difficulty\nof the casual user writing plugins as they are required to be intimately\nknowledgeable of pitivi's internal code.</p>\n<p>The tried and tested solution to this problem is to develop a plugin\nAPI, the API will handle any communication from the plugin to pitivi by\nabstracting pitivi.instance.PiTiVi with a stable API. The plugin can\nthen make simple calls such as api.gui.add_menu_item(...) and be\nconfident that the API will not change from version to version.</p>\n<h2 id=\"api\">API</h2>\n<h3 id=\"design-considerations\">Design considerations</h3>\n<p>The api has a slight problem in that it may be initialised before pitivi\nis ready to be modified, This is solved at the moment by 'locking' the\napi (via decorators for ease of use..) until the main pitivi codebase\nemits a 'ready' signal, the api will raise an InterfaceNotReadyError\nexception if its called before then</p>\n<h3 id=\"current-implementation\">Current implementation</h3>\n<p>The current API uses epydoc for its documentation and is structured as\nfollows:</p>\n<ul>\n<li>pitivi\n<ul>\n<li>PluginInterface\n<ul>\n<li>gui\n<ul>\n<li>show_gui(self, *args, **kwargs) shows or hides the\nmain application window depending on the value of\n'visible'</li>\n<li>add_menu_item(self, *args, **kwargs) Adds a menu\nitem to the appropriate main window menu</li>\n<li>remove_menu_item(self, name) removes the given menu\nitem from the user interface</li>\n<li>remove_ui(self) removes all changes this instance of\nthe plugininterface has made to the user interface</li>\n</ul>\n</li>\n<li>Project\n<ul>\n<li>add_source</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"settings\">Settings</h2>\n<p>The current api simply requires that plugin.settings exists and\n(un)pickles that data to save/load settings, there is a problem there\nwith human readabity and maybe even security, also its not that kind to\nversion upgrades.</p>\n<h3 id=\"current-implementation1\">Current implementation</h3>\n<p>The current implementation is inspired by Django's model setup,\nessentially the plugin authors create a class, in that class are Fields\n(special pitivi python objects that can handle validation and such) that\ndescribe settings.</p>\n<p>for example the Field for a setting that must be a single line string\nwould be</p>\n<pre><code>mySetting = pluginsettings.CharField('a_string', default='hello world!')\n</code></pre>\n<p>At the moment plugin.settings must be a\npitivi.pluginsettings.SettingsStore object, this object can then create\nxml data to store and retrive the settings as needed.</p>\n<p>a further example for the entire settings store is:</p>\n<pre><code>class ConfigureTest_Settings(pluginsettings.SettingsStore):\n    \"\"\" Our plugins settings \"\"\"\n\n    variable1 = pluginsettings.CharField('astring', default='hello world!')\n    variable2 = pluginsettings.FloatField('float_field', default=10)\n</code></pre>\n<h4 id=\"fields\">Fields</h4>\n<p>This is a list of the current fields available:</p>\n<ul>\n<li>BooleanField</li>\n<li>CharField</li>\n<li>FloatField</li>\n<li>IntegerField</li>\n<li>TextField</li>\n<li>NullField</li>\n</ul>\n<h2 id=\"configuration\">Configuration</h2>\n<p>The current api only makes one consideration regarding configuration,\nthat is that the plugin class object must be IConfigurable zope\ninterface compatible, which essentially means must provide the\nconfigure() method - this requires plugins to create their own\nconfiguration dialogs and such, which is a pain for plugin developers\nand a pain for anyone that likes consistency in their applications To\nsolve this I am proposing an interface that will be able to take\nsettings defined by a plugin and turn that into a sensible gtk\nconfiguration dialog.</p>\n<h3 id=\"current-implementation2\">Current implementation</h3>\n<p>The current implimentation is a mix-in object that replaces the\nconfigure() method with our own gui-builder code (plugin authors that\nneed more flexability can create their own configure() method)</p>\n<p>the gui-builder code simply parses the current settings object and is\nable to build a gui from the fields provided, for example it will\nprovide a text entry for CharField objects. what 'widget' is used to\ndraw each settings can be further customised by providing the setting\nwith a widget argument, for example:</p>\n<pre><code>pw_string = CharField('a password string', default='', max_length=32,\n                      widget=pluginsettings.charField_widget_passworded)\n</code></pre>\n<p>this code will provide an input widget where the characters are starred\nout which is appropriate for a password field. plugins can even provide\ntheir own widgets by subclassing FieldWidget but this is absolutly not\nnessasserry</p>\n<h4 id=\"custom-configuration-widget-example\">custom configuration widget example</h4>\n<p>this will check to see if the current screen is composited and emit a\nwarning</p>\n<pre><code>composite_warning = _('Warning: you seem to have compositing enabled, this may \\\nresult in a severe slowdown when recording your screencast.')\nclass composite_check(pluginsettings.FieldWidget):\n\n    def __init__(self, field=None):\n        pluginsettings.FieldWidget.__init__(self, field)\n\n        self.container = gtk.HBox(False, 6)\n\n        self.icon = gtk.Image()\n        self.icon.set_from_stock(gtk.STOCK_DIALOG_WARNING, 6)\n        self.container.pack_start(self.icon, False, True, 0)\n        self.icon.show()\n\n        self.label = gtk.Label(composite_warning)\n        self.label.set_line_wrap(True)\n        self.container.pack_start(self.label, True, True, 0)\n        self.label.show()\n\n\n        self.add(self.container)\n        self.container.show()\n\n        if not self.is_composited():\n            #we check for a composited desktop with this\n            self.container.hide()\n\n    def get_value(self):\n\n        return None\n\n\nclass Settings(pluginsettings.SettingsStore):\n\n    warning = NullField('', widget=composite_check, draw_label=False)\n\n    ... more settings go here ...\n</code></pre>\n<h5 id=\"custom-configuration-widget-example-preview\">custom configuration widget example - preview</h5>\n<p>The above example produces the following image</p>\n<p><img src=\"Config-custom-widget.png\" alt=\"\" title=\"Config-custom-widget.png\"></p>\n<h2 id=\"plugin-examples\">Plugin Examples</h2>\n<h3 id=\"plugin-that-demonstrates-the-configuration-dialog-builder\">Plugin that demonstrates the configuration dialog builder</h3>\n<pre><code>#!/usr/bin/env python\n#       configure_test.py\n#\n#       Copyright 2008 Gordon Allott &lt;gordallott@gmail.com&gt;\n#\n#       This program is free software; you can redistribute it and/or modify\n#       it under the terms of the GNU General Public License as published by\n#       the Free Software Foundation; either version 3 of the License, or\n#       (at your option) any later version.\n#\n#       This program is distributed in the hope that it will be useful,\n#       but WITHOUT ANY WARRANTY; without even the implied warranty of\n#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#       GNU General Public License for more details.\n#\n#       You should have received a copy of the GNU General Public License\n#       along with this program; if not, write to the Free Software\n#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n#       MA 02110-1301, USA.\n#\n#\n\n\nfrom zope.interface import Interface, Attribute\nimport zope.interface as interface\nfrom pitivi import plugininterface\nfrom pitivi import plugincore\nfrom pitivi import pluginsettings\nfrom pitivi.pluginsettings import *\nfrom random import random\n\nclass Interface_Settings(pluginsettings.SettingsStore):\n\n    # this is a CharField setting, a charfield is used to store simple strings\n    # we set its priority to 0 to make sure that its right at the top of our\n    # settings dialog (lower values = drawn first)\n    astring = CharField('a string', default='hello world!',\n                        max_length=32, priority=0)\n\n    # this is similar to the previous setting apart from that we use a different\n    # 'widget' to draw the settings value, specifically one that will hide the\n    # password from view\n    pw_string = CharField('a password string', default='apassword', max_length=32,\n                          widget=pluginsettings.charField_widget_passworded)\n\n    # this is a FloatField setting, it will store floating point numbers,\n    # by default this uses a 'spinner' widget in the settings dialog\n    afloat = FloatField('put a number in here', default=10.0, priority=200,\n                        min_value=0.0, max_value=20.0)\n\n    # this is similar to the previous setting but instead will only store\n    # integer values\n    anint = IntegerField('put an int in here', default=5, priority=100)\n\n    # this is another floating point setting but we use a different widget\n    # to draw it, the scaleField widget will allow people to configure the\n    # setting by draging a handlebar around\n    arange = FloatField('push this widget around', default=10.0, priority=500,\n                        max_value=100.0, min_value=0.0,\n                        widget=pluginsettings.scaleField_widget)\n\n    airange = IntegerField('integer based range', default=10, priority=499,\n                           max_value=100, min_value=0,\n                           widget=pluginsettings.scaleField_widget)\n\n    # this is a boolean value, it will store True/False values, we set draw_label\n    # to false because the checkbutton thats used to draw this setting already\n    # contains a label inside it\n    truth = BooleanField('this is a truth value', default=True, draw_label=False)\n\n    # second tag here - this is a 'realworld' example,\n    # we pass each item two tags, the first tag indicates a 'major' tag and\n    # the second indicates a 'minor' tag, if there is more than one major tag\n    # given then the settings dialog will use a notebook to draw the settings,\n\n    username = CharField('username', default='Simon', max_length=64,\n                         priority=0, tags=('Realworld', 'user info'))\n    password = CharField('password', default='', max_length=32,\n                          widget=pluginsettings.charField_widget_passworded,\n                          tags=('Realworld', 'user info'))\n\n    fish_size = FloatField('Fish Size', default=15, priority=35,\n                           max_value=100, min_value=1,\n                           tags=('Realworld', 'Fish Configuration'),\n                           widget=pluginsettings.scaleField_widget)\n\n    fish_number = IntegerField('Number of fish', default=15, priority=1,\n                               max_value=1000, min_value=0,\n                               tags=('Realworld', 'Fish Configuration'),\n                               widget=pluginsettings.scaleField_widget)\n\n\n# this is our main plugin class thats called by pitivi, we subclass it from\n# ConfigureBuilder so that we can have a settings dialog built for us\nclass Configure_Test(pluginsettings.ConfigureBuilder):\n\n    interface.implements(plugincore.IPlugin, plugincore.IConfigurable)\n\n    name = 'configure test plugin'\n    category = 'test'\n    description = 'a test plugin, just gets the configure test going'\n    version = '1.0'\n    authors = 'Gordon Allott'\n    enabled = True\n\n    # for our settings we must create an instance of our custom settings object\n    settings = Interface_Settings()\n\n    def __init__(self):\n        pass\n\n\n    def __call__(self, manager):\n        \"\"\" called when the plugin is loaded \"\"\"\n        pluginsettings.ConfigureBuilder.__init__(self, manager)\n        self.manager = manager\n\n        # load our saved settings\n        self.manager.loadSettings(self)\n\n        # connect up the 'enabled changed' signal, its a signal thats emitted\n        # when the plugin.enabled state is changed somehow, obviously our\n        # plugin has to take note of that and disable/enable its functionality\n        # accordingly\n        self.manager.connect('plugin-enabled-changed', self._enabled_changed_cb)\n\n\n    def cleanup(self):\n        \"\"\" used to remove any items and stuff we have added \"\"\"\n        self.manager.saveSettings(self)\n\n\n    def initialize(self, ref):\n        \"\"\" called when the interface is ready to be manipulated \"\"\"\n        pass\n\n\n    # -- callbacks --\n    def _enabled_changed_cb(self, manager, plugins):\n        \"\"\" called when some plugins state has changed, maybe this one \"\"\"\n        if self.name in plugins:\n            if self.enabled:\n                self.initialize(None)\n            else:\n                self.cleanup()\n</code></pre>\n<h4 id=\"preview-of-the-previous-example\">Preview of the previous example</h4>\n<p><img src=\"Config-example.png\" alt=\"\" title=\"Config-example.png\"></p>\n\n</div>\n\n\n\t"});