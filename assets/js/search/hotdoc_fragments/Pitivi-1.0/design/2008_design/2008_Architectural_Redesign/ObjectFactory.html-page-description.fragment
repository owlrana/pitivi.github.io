fragment_downloaded_cb({"url": "Pitivi-1.0/design/2008_design/2008_Architectural_Redesign/ObjectFactory.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"ObjectFactory.md\">\n<h1 id=\"overall\">Overall</h1>\n<blockquote>\n<p><strong>ObjectFactory are the descriptions of objects producing and/or\nconsuming data streams.</strong></p>\n</blockquote>\n<ul>\n<li>They contain a list of the Stream(s) they can produce and/or\nconsume.</li>\n</ul>\n<blockquote>\n<p>This implies <strong>ALL</strong> The potential streams the factory can\nprovide/consume.</p>\n</blockquote>\n<blockquote>\n<p>Ex: A <strong>FileSourceFactory</strong> of a raw DV File will list the following\nstreams:</p>\n<ul>\n<li><code>video/x-dv,systemstream=True</code>, The container stream,</li>\n<li><code>video/x-dv,systemstream=False</code>, The I-Frame only DV video stream,</li>\n<li><code>video/x-raw-yuv</code>, The decoded raw video stream</li>\n<li><code>audio/x-raw-int</code>, The audio stream</li>\n</ul>\n</blockquote>\n<ul>\n<li>They produce GStreamer elements for all, or a selected number of,\nstreams.</li>\n</ul>\n<blockquote>\n<p>Some factories will be able to produce a different GStreamer element\nevery time, some will only be able to produce one at a time (Ex:\nVideo4Linux source, or audio sink with retarded backend that can have\nmultiple sockets opened).</p>\n</blockquote>\n<h2 id=\"properties\">Properties</h2>\n<ul>\n<li><code>Name</code>, unique for that given ObjectFactory instance type.</li>\n<li><code>InputStreams</code>, a list of Stream(s) the given factory can consume.\nEmpty for SourceFactory.</li>\n<li><code>OutputStreams</code>, a list of Stream(s) the given factory can produce.\nEmpty for SinkFactory.</li>\n</ul>\n<h2 id=\"class-properties\">Class Properties</h2>\n<ul>\n<li><code>Description</code> , a description of the ObjectFactory</li>\n</ul>\n<h2 id=\"methods\">Methods</h2>\n<ul>\n<li><code>makeBin(streams=[])</code>, returns a gst.Bin for the given Streams. If\nno Streams are specified, then a gst.Bin for all the available\nstreams is returned. If only one Stream is specified, then the\ngst.Bin returned will not contain any <code>queue</code> in it.</li>\n</ul>\n<h1 id=\"examples\">Examples</h1>\n<h2 id=\"filesource\">FileSource</h2>\n<p>Describes the properties of a file specified by:</p>\n<ul>\n<li>A URI</li>\n<li>A list of streams the file can provide (This information can come\nfrom the Discoverer, or some other source)</li>\n<li>Metadata regarding the file</li>\n</ul>\n<p>This might be one of the most commonly used ObjectFactory. A single\ninstance of a FileSourceFactory can be used for:</p>\n<ul>\n<li>Previewing the file</li>\n<li>Using it many times in the timeline (which have different position,\nin/out points, streams used, etc...)</li>\n</ul>\n<h2 id=\"sourcedevicefactory\">SourceDeviceFactory</h2>\n<p>Describes a Hardware Device that can produce streams. This ObjectFactory\nwill most likely be provided by the HardwareBrowser.</p>\n<ul>\n<li>A description of the hardware</li>\n<li>A list of streams it can provide (An local SoundCard could provide\nseveral streams if it has several inputs).</li>\n</ul>\n<p>This will be used most likely when recording or capturing.</p>\n<h2 id=\"operationfactory\">OperationFactory</h2>\n<p>Describes any kind of operation, which can be an A/V Effect, an Encoding\ncontainer, or even a Hardware processing effect (like OpenGL powered),\nor even more complex effect.</p>\n<ul>\n<li>A list of streams it can process</li>\n<li>A list of resulting streams it can/will output</li>\n</ul>\n<h1 id=\"interfaces\">Interfaces</h1>\n<h2 id=\"linkedfactoryinterface\">LinkedFactoryInterface</h2>\n<p>This allows aggregating streams from various factories at the same time,\nwith an eventual offset between each streams.</p>\n<h3 id=\"examples1\">Examples</h3>\n<ul>\n<li>Audio and Video captured on separate devices during a shoot. We\ncould link all those separate A/V content into one source, allowing\nfixing of synchronization, and then be usable as one item in a\ntimeline.</li>\n</ul>\n<!-- -->\n<ul>\n<li>LocalSourceDevicesFactory : SourceDeviceFactory aggregating all\navailable LocalSourceDevice on the current system. We can then\neasily switch between the various devices, while keeping track of\none consistent object.</li>\n</ul>\n<!-- -->\n<ul>\n<li>LocalSinkDevicesFactory : Same as above but for all available A/V\nsinks on the device.</li>\n</ul>\n<!-- -->\n<ul>\n<li>LinkedOperationFactory : Synchronized effect for use in the\npipeline. Imagine a 'thunder' effect that has synchronized audio and\nvideo effect.</li>\n</ul>\n<!-- -->\n<ul>\n<li>MultipleQualitySourceFactory : SourceFactory that can provide a\nvariety of different 'qualities' off the content. This could enable\nswitching between a lower-quality (fast for editing) and a\nhigher-quality (needed for final rendering).</li>\n</ul>\n<h2 id=\"groupedfactoryinterface\">GroupedFactoryInterface</h2>\n<p>This allows creation groupings of different factories with:</p>\n<ul>\n<li>time offsets for each factory,</li>\n<li>different in-out points per factory,</li>\n<li>priorities of placement of each factory</li>\n</ul>\n<h1 id=\"ideas\">Ideas</h1>\n<p>Maybe we should have a way to specify the properties/methods/... of some\nof these use-case:</p>\n<ul>\n<li>OnlineFactoryInterface : For sources (or sinks/destinations) which\ncorrespond to non-local content, which requires doing an action\n(Download/Upload) to get/use a local content. Ex : Youtube sources,\nwhich requires downloading a local copy to edit it. DV VCR, which\nrequires doing a capture.</li>\n</ul>\n<!-- -->\n<ul>\n<li>LiveFactoryInterface : This applies to all factories that only\nconsumes/processes/produces live. Ex: a Webcam source, or a\nStreamingSink. They too require a 'record' phase in order to produce\na local, editable, copy.</li>\n</ul>\n<p><img src=\"Objectfactory-hierarchy.png\" alt=\"ObjectFactory hierarchy\" title=\"ObjectFactory hierarchy\" id=\"objectfactory-hierarchy\">{width=\"600\"}</p>\n\n</div>\n\n\n\t"});