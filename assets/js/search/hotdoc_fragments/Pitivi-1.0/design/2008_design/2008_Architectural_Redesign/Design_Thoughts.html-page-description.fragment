fragment_downloaded_cb({"url": "Pitivi-1.0/design/2008_design/2008_Architectural_Redesign/Design_Thoughts.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"Design_Thoughts.md\">\n<h1 id=\"2008-architectural-redesigndesign-thoughts\">2008 Architectural Redesign/Design Thoughts</h1>\n<p>This is a listing, not entirely sorted, of thoughts, remarks, things to\ndo, regarding PiTiVi's design, uses, etc...</p>\n<p>Eventually, these ideas/thoughts/remarks ... will end up being split up\nfor a full-size (re)design/refactor document.</p>\n<p>They could be sorted as following:</p>\n<ul>\n<li>Coding Style : Urgent</li>\n<li>Core Features</li>\n<li>(long term) goals</li>\n<li>Vision (use cases ?)</li>\n</ul>\n<h2 id=\"code-review\">Code Review</h2>\n<ul>\n<li>What is too slow ?</li>\n<li>What is not flexible enough ?</li>\n<li>What is not re-usable ?</li>\n<li>What is hard to use ?</li>\n<li>What is unclear ?</li>\n<li>What is not needed ?</li>\n<li>What is in the wrong location ?\n<ul>\n<li>Split up code</li>\n</ul>\n</li>\n</ul>\n<p>Actual inline-review done in the 'code-review' branch here :\n<a href=\"http://gitorious.org/projects/pitivi/repos/mainline\">http://gitorious.org/projects/pitivi/repos/mainline</a></p>\n<h2 id=\"fundamental-issues-and-goals\">Fundamental issues and goals</h2>\n<p>These issues/goals are not ordered, since they are all equally\nimportant.</p>\n<ul>\n<li><strong>No code shall access private values directly</strong>\n<ul>\n<li>Use setter/getter and python 'property' mapper</li>\n<li>Ex: <code>myprop = property(_get_myprop,_set_myprop)</code></li>\n</ul>\n</li>\n</ul>\n<!-- -->\n<ul>\n<li><strong>Core code shall NOT contain any UI-specific code</strong> (and\nvice-versa)\n<ul>\n<li>This breaks the fundamental Core/UI separation</li>\n<li>Any code in <em>core</em> that has ui-specific code should be moved to\npitivi.ui modules</li>\n<li>And the opposite for core code in the UI (ex.\n<code>pitivi.ui.plumber</code>)</li>\n</ul>\n</li>\n</ul>\n<!-- -->\n<ul>\n<li><strong>All Core/UI classes can be subclassable for specific usage</strong>\n<ul>\n<li>This is essential for full pitivi flexibility, for having all\nkinds of plugins, for having different UI, etc...</li>\n</ul>\n</li>\n</ul>\n<!-- -->\n<ul>\n<li><strong>Splitup code in subdirectories/submodules</strong>\n<ul>\n<li>Maybe not as much as one class per file... but that would be a\ngood goal</li>\n<li>Definitely ONE base class per file though</li>\n</ul>\n</li>\n</ul>\n<!-- -->\n<ul>\n<li><strong>UI is NOT compulsory</strong> ==&amp;gt; <strong>pitivi can be used as a LIBRARY</strong>\n<ul>\n<li>There are several tools for which we need all the code from\npitivi core without a UI implementation</li>\n<li>Ex : rendering backends, command-line/scripting tools, ....</li>\n<li>Disambiguate the naming somewhere\n<ul>\n<li><code>pitivi</code> : python module/library</li>\n<li><code>PiTiVi</code> : application using the <code>pitivi</code> module</li>\n</ul>\n</li>\n<li>Still, we should have most of the UI logic in that library, but\nwithout any forced implementation (like qt/gtk/win32...)</li>\n</ul>\n</li>\n</ul>\n<!-- -->\n<ul>\n<li><strong>No gnome/gtk/gobject/gst specific code in base classes</strong>\n<ul>\n<li>This should go in subclasses</li>\n<li>Create our own event-based interface (to remove dependency on\ngobject.GObject)\n<ul>\n<li>Johan might have ideas about this</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- -->\n<ul>\n<li><strong>Use <code>generators/yield</code> wherever it can be applied</strong>\n<ul>\n<li>Speedup and memory usage improvement</li>\n</ul>\n</li>\n</ul>\n<!-- -->\n<ul>\n<li><strong>The only HARD DEPENDENCIES of pitivi are python core libraries and\ngstreamer</strong>\n<ul>\n<li>All other dependencies are optional and should be used from\nplugins</li>\n</ul>\n</li>\n</ul>\n<!-- -->\n<ul>\n<li><strong>Remove the global instance code</strong>\n<ul>\n<li>No code should depend on a single instance of application and\nproject</li>\n<li>Needed to be able to load many projects in one instance (amongst\nother things)</li>\n<li>The majority of the pitivi module should be non-application\nmodules</li>\n</ul>\n</li>\n</ul>\n<!-- -->\n<ul>\n<li><strong>Unit tests for pitivi core</strong></li>\n</ul>\n<!-- -->\n<ul>\n<li><strong>Prepare for Python 3</strong>\n<ul>\n<li>Article/presentation by Guido about this :\n<a href=\"http://www.artima.com/weblogs/viewpost.jsp?thread=227041\">http://www.artima.com/weblogs/viewpost.jsp?thread=227041</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"code-review1\">Code Review</h2>\n<p>Not at all sorted</p>\n<h3 id=\"file-saveload\">File save/load</h3>\n<p>It seriously needs to be rethinked.</p>\n<ul>\n<li>Allow formats to create their own subclasses of core classes\n<ul>\n<li>Subclassing FileSource to add format-specific information</li>\n<li>Subclassing FileSourceWidget to show that format-specific\ninformation in the UI</li>\n</ul>\n</li>\n<li>Pluggable format support</li>\n<li>See Undo/Redo</li>\n<li>We need a native PiTiVi format</li>\n<li>Need to be able to save files used in the project</li>\n<li>Handle files/directories being moved, or loading the project on a\ndifferent computer</li>\n<li>Simple support for playlists (ELD, PLS, ASX ?)</li>\n</ul>\n<h3 id=\"undoredo\">Undo/Redo</h3>\n<ul>\n<li>Some actions might be specific to a plugin</li>\n</ul>\n<h3 id=\"layer-support-in-compositions\">Layer support in compositions</h3>\n<ul>\n<li>This is currently implemented using hacks</li>\n</ul>\n<h3 id=\"timelineobjects\">TimelineObjects</h3>\n<ul>\n<li>Actually use ObjectFactory for producing its content</li>\n<li>Remove limitation of only one brother per object</li>\n<li>Allow re-using indentical source/composition many times in a\ncomposition\n<ul>\n<li>Fully synchronized (modifications to one instance are spread to\nall instances)</li>\n<li>Not synchronized (they're copies)</li>\n<li>Half synchronized (only some properties modifications are\nsynchronized to all instances)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"objectfactory\">ObjectFactory</h3>\n<ul>\n<li>Clarify its usage\n<ul>\n<li>It contains the global information of objects you can use in the\ntimeline</li>\n<li>For *any* object you can use in the timeline (source, fx,\ntransition, composition, etc....)</li>\n</ul>\n</li>\n<li>Create notion of <code>SubObjectFactory</code>\n<ul>\n<li>They use a smaller area/time of the <em>parent</em> object (cutting a\ncaptured video)</li>\n<li>Or they could be <strong>corrected/modified</strong> versions of the original\nsource (i.e. they have extra effects applied to the source)\n<ul>\n<li>Colour balance correction</li>\n<li>Audio Correction</li>\n<li>Media conversion (ex : Use <code>goom</code> to make a video stream out\nof an audio track)\n<ul>\n<li>The 'media-converted' ones could maybe done on the fly\nif you add a file of a given media type (ex:audio) into\na track of anothe media type (ex:video).</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Allow easy transcoding, re-rendering or re-muxing of\nSubObjectFactory.</li>\n<li>Allow adding extra (meta)data</li>\n</ul>\n<h3 id=\"logging\">Logging</h3>\n<ul>\n<li>Switch to a smarter and more efficient debugging system\n<ul>\n<li>Use logging module ?</li>\n<li>do as <code>flumotion</code> ?</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"plugin-system\">Plugin system</h3>\n<ul>\n<li>Figure out how to cleanly solve the problem of plugins extending\nboth CORE and UI classes\n<ul>\n<li>flumotion use some kind of bundles for this</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"smartbin-and-playground\">SmartBin and Playground</h3>\n<p>This was originally created to cope with 0.8 issues</p>\n<ul>\n<li>Do we still need the playground ??</li>\n<li>SmartBin isn't flexible enough\n<ul>\n<li>We might need to have more than two running at the same time</li>\n<li>Doesn't support being connected to more than one sink</li>\n<li>Need to support features like Viewing Video while recording\nVideo AND Audio</li>\n</ul>\n</li>\n</ul>\n<p>An idea might be to have <code>Producer</code>s and <code>Consumer</code>s.</p>\n<ul>\n<li>Producer\n<ul>\n<li>Can be a Timeline, live stream, File source, camera, webcam ,...\n(more or less like SmartBin now)</li>\n<li>It has a clean way of querying what it can produce</li>\n<li>We can connect multiple times to a stream (Audio, Video, ...) it\nproduces</li>\n</ul>\n</li>\n<li>Consumer\n<ul>\n<li>Can be an Encoder, Hardware sinks, Raw File renderer, Network\nStream renderer, ...</li>\n<li>Has a buffering property</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"naming-inconsistencies\">Naming inconsistencies</h3>\n<p>Make sure the naming is coherent and comprehensible</p>\n<ul>\n<li>Get rid of the notions of 'threads' in bins (sooooo 0.8)</li>\n<li>Use proper naming from the editing world</li>\n<li>Add a glossary in the documentation</li>\n</ul>\n<h3 id=\"temporary-files\">Temporary files</h3>\n<p>Thumbnails, captures, etc...</p>\n<ul>\n<li>Where do we store them ?</li>\n<li>How do we manage them ?</li>\n</ul>\n<h3 id=\"hardware-source-and-sinks\">Hardware source and sinks</h3>\n<ul>\n<li>Move plumber to core</li>\n<li>Have some discovery utility (i.e. several audio/video sinks)\n<ul>\n<li>Have it subclassable\n<ul>\n<li>Use HAL on linux</li>\n<li>Use ??? on win, etc....</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Have some generic classification system (os/system agnostic)\n<ul>\n<li>Audio</li>\n<li>Video</li>\n<li>Source\n<ul>\n<li>Local</li>\n<li>Camera</li>\n<li>Network</li>\n</ul>\n</li>\n<li>Sink\n<ul>\n<li>Local</li>\n<li>Network</li>\n</ul>\n</li>\n<li>???</li>\n</ul>\n</li>\n<li>See SmartBin and Playground above</li>\n</ul>\n<h3 id=\"cache-rendering\">Cache rendering</h3>\n<ul>\n<li>needed for complex videos/operation</li>\n<li>Have a caching system for frame forward/backward operation\n<ul>\n<li>Would act like a queue, except it would intercept seeks, do the\noriginal one, then do a second [1s before, 1s after] seek to\nhave the data available straight away for step-by-step seeking</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"losless-editing\">Losless editing</h3>\n<ul>\n<li>For I-frame only codecs (DV, JPEG,...), we should be able to only\ndecode/process/encode parts that have be modified\n<ul>\n<li>Would require gnonlin and core pitivi classes to support non-raw\nstreams</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"capture-support\">Capture support</h3>\n<ul>\n<li>Have base classes for capture support in core</li>\n<li>See Hardware source and sinks</li>\n<li>We <strong>absolutely</strong> need support for DV and HDV</li>\n</ul>\n<h3 id=\"flexible-source-providerbrowser-support\">Flexible 'source provider/browser' support</h3>\n<p>Currently we only get sources from local files (even worse, it's using\ngnome-specific things)</p>\n<ul>\n<li>\n<p>Make it generic</p>\n</li>\n<li>\n<p>It provides ObjectFactory objects</p>\n</li>\n<li>\n<p>Allow acces to various kinds of source provider</p>\n<ul>\n<li>Local providers (filesystem, F-Spot, Gnome media (SoC project),\n...)</li>\n<li>Network providers (Media Asset Management)</li>\n<li>P2P ? Using telepathy and tubes ?</li>\n</ul>\n</li>\n<li>\n<p>Source providers might have extra information ==&amp;gt; ObjectFactory\nsubclasses</p>\n</li>\n<li>\n<p>Figure out what's the best way to solve this issue</p>\n<ol>\n<li>Use a source provider (let's say youtube) and grab some files</li>\n<li>You want to modify those files (let's say apply a colourbalance,\nor cut out what you need) to have SubObjectFactory</li>\n<li>You save your project (where/how do you save those files ? Do we\nleave them as a youtube link ?)</li>\n<li>You reload your project... but you don't need the youtube\nbrowser anymore (you've already got your sources)</li>\n</ol>\n<ul>\n<li>\n<ul>\n<li><strong>PROBLEM</strong> Disambiguate SourceProvider and SourceBrowser.\nI'd say the difference is that stuff from SourceProvider(s)\nhave to be moved in the SourceBrowser before being used in\nthe timeline.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>See also the ideas in ObjectFactory above</p>\n</li>\n</ul>\n<h3 id=\"marker-points-keyframes\">Marker points / KeyFrames</h3>\n<p>Here keyframes are not I-frames but 'key positions'</p>\n<ul>\n<li>Add support in:\n<ul>\n<li>ObjectFactory (interesting points, user-introduced data, could\nbe stored with/along the file...)</li>\n<li>TimelineObject (instance specific property modification)</li>\n<li>UI</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"source-flexibility\">Source flexibility</h3>\n<ul>\n<li>Support multiple versions of one source\n<ul>\n<li>Ex :\n<ul>\n<li>low resolution versus HD/4K</li>\n<li>Distributed/P2P files (first download lowest resolution)</li>\n</ul>\n</li>\n<li>Use thumbnail when file not available yet.</li>\n</ul>\n</li>\n<li>if it's a network URI, option to save it locally\n<ul>\n<li>detect if remote source has changed</li>\n</ul>\n</li>\n<li>Support for separate index (save/load support)</li>\n<li>Add basic tests to make sure the sources will behave properly with\npitivi\n<ul>\n<li>ex : testing seeking support</li>\n<li>If not, propose transcoding, or plugin to download, etc...</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"multiple-video-support\">Multiple Video support</h3>\n<p>There's two different use-cases in fact</p>\n<ul>\n<li>Steroscopic or multi-angle support (multiple video tracks)</li>\n<li>Editing together multiple videos from the same scene (one video\ntrack)\n<ul>\n<li>You want a way to view all the input videos at the same time,\nsynchronized, so you know which ones to select at any given\npoint</li>\n<li>This of it as a non-live mixing-desk</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"effect-support\">Effect support</h3>\n<ul>\n<li>Have a <code>gst_launch</code> plugin where users can create their own freeform\neffect pipeline</li>\n<li>Allow concatenation/coupling of existing effects into a bigger one\n<ul>\n<li>Bonus for adding some scripting in it !</li>\n</ul>\n</li>\n<li>Have Audio+Video effects\n<ul>\n<li>They're in fact two/more separate effects that have\nsynchronization</li>\n<li>Ex : photo flash effect : you want to have the 'flash' sound in\nsync with the 'whiteout'/still frame on the video side</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"scriptingtemplatescenario-system\">Scripting/Template/Scenario system</h3>\n<p>Allow easy creation of (parts of) the Timeline</p>\n<ul>\n<li>Should have a clean content/Script separation\n<ul>\n<li>Ex : Interview script : have the interview person's name\nseparated from the actual video on which to overlay his name</li>\n</ul>\n</li>\n<li>Allow subclassing\n<ul>\n<li>Ex : You can create different ways of displaying the\ninterviewee's name, different ways to blend in/out, ...</li>\n</ul>\n</li>\n<li>Have a repository for those scripts/scenarios\n<ul>\n<li>People can easily share/use/reuse existing scenarios</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"textsubtitle-support\">Text/Subtitle support</h3>\n<p>How do we handle this properly ?</p>\n<ul>\n<li>Text track ?</li>\n<li>Use case : karaoke/subtitle overlay</li>\n</ul>\n<h3 id=\"missing-feature-support\">Missing feature support</h3>\n<p>Allow cleanly support Projects using unavailable\nsubclasses/plugins/effects.</p>\n<ul>\n<li>Might not be available</li>\n<li>Might be proprietary/custom</li>\n<li>Older version of PiTiVi\n<ul>\n<li>Provide a way to upgrade the feature/plugin</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"centraldistributed-repository-of-pitivi-plugins\">Central/Distributed repository of PiTiVi plugins</h3>\n<h3 id=\"missing-gstreamer-plugin-support\">Missing (GStreamer) plugin support</h3>\n<p>Distributions should support this !</p>\n<h3 id=\"easy-transcoding-of-sources\">Easy transcoding of sources</h3>\n<ul>\n<li>Allow transcoding sources only</li>\n<li>Useful also for making sources more editing-friendly</li>\n<li>Or to have lower resolution versions to work with</li>\n</ul>\n<h3 id=\"gnonlin\">GNonLin</h3>\n<p>Optimize the following use cases</p>\n<ul>\n<li>Resizing/Trimming\n<ul>\n<li>By end (modifying media_duration + duration)</li>\n<li>By beginning (modifying\nmedia_start+start+media_duration+duration)</li>\n</ul>\n</li>\n<li>Moving many objects at once</li>\n</ul>\n<p>One idea for this would be to have a 'block-rebuild' property on\nGnlComposition that would mark down that is has (or not) to rebuild the\ninternal stack, but postpone it until the property has been set back to\nFalse.</p>\n<h3 id=\"gstreamer\">GStreamer</h3>\n<ul>\n<li>interlaced support\n<ul>\n<li>caps (differentiate raw frame/fields)</li>\n<li>Buffer Flags (TFF, Repeat)</li>\n<li>... and obviously support in virtually all relevent plugins</li>\n</ul>\n</li>\n<li>Perfect Profesionnal Colourspace support\n<ul>\n<li>Various Subsampling + Chroma placement (right now we don't make\na difference between 4:2:0 jpeg/mpeg2/dv-ntsc ... whereas they\nhave different chroma placement)</li>\n<li>Various Clamping matrices (HDYC for example)</li>\n<li>FAST and bit-accurate converters\n<ul>\n<li>This might require making a generic colourspace converter\nbin which searches all required/available colourspace\nconverters</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"website\">Website</h3>\n<ul>\n<li>We need more screenshots</li>\n<li>Propose nightly builds</li>\n</ul>\n<h2 id=\"use-cases\">Use Cases</h2>\n<p>These are some (long term) ideas I have</p>\n<h3 id=\"effect-ideas\">Effect ideas</h3>\n<ul>\n<li>GoogleMaps/OpenStreetMap plugin\n<ul>\n<li>Use maps to show a trip</li>\n<li>Zoom-in/zoom-out/move from location to location between the\nvarious steps</li>\n<li>Could use photo geotags to automatically known where to go</li>\n</ul>\n</li>\n</ul>\n<!-- -->\n<ul>\n<li>Photo Flash\n<ul>\n<li>Could be a nice way to do transitions when doing slideshows</li>\n<li>Could have a 'flash' sound on the audio track, sync-ed with it</li>\n</ul>\n</li>\n</ul>\n<!-- -->\n<ul>\n<li>Film-reel at slow-speed\n<ul>\n<li>Start from a still frame/picture</li>\n<li>Gradually speed up the movie</li>\n<li>You see the 'film-reel border' moving (i.e. at some points the\ninter-frame black borders will be visible)</li>\n<li>Have a flickering soundtrack</li>\n</ul>\n</li>\n</ul>\n\n</div>\n\n\n\t"});