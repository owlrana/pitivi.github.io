fragment_downloaded_cb({"url": "Pitivi-1.0/design/UI_Implementation.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"UI_Implementation.md\">\n<h1 id=\"ui-implementation\">UI Implementation</h1>\n<p>For the previous design document, see <a href=\"Obsolete:_Advanced_UI_Implementation.md\">Obsolete: Advanced UI\nImplementation</a></p>\n<p>This document <strong>does not reflect the existing codebase</strong>, but rather a\nroad map for future development, and a general introduction to the\nPiTiVi design philosophy.</p>\n<h1 id=\"todo\">Todo</h1>\n<ul>\n<li>document markers</li>\n<li>document keyframes</li>\n<li>explain the concept of a receiver.</li>\n</ul>\n<h1 id=\"concepts\">Concepts</h1>\n<p>The goal of the design is to build a UI which supports the following\nfeatures:</p>\n<ul>\n<li>basic editing</li>\n<li>basic effects</li>\n<li>compositing</li>\n<li>multi-track editing</li>\n<li>multi-layer editing*</li>\n<li>multiple selection</li>\n<li>noun-verb interaction</li>\n<li>direct manipulation wherever possible</li>\n<li>leaving behavior up to the core implementation</li>\n</ul>\n<p>(*) It is important to distinguish between a <strong>track</strong>, and a <strong>layer</strong>\nin application terminology. Existing video editors use the term\n<strong>track</strong> to refer to a UI object which represents a stream of video\nwith a sequence of sources. PiTiVi refers to this as a <strong>composition</strong>.\nThe term <strong>track</strong> in PiTiVi means a separate channel of output: for\nexample, audio and video are in separate tracks.</p>\n<p>This is distinguished from the concept of a <strong>layer</strong> which is directly\nrelated to the notion of <strong>compositing</strong>. Within a track, sources have a\nproperty called <strong>priority</strong> which determines what will appear when the\nplay-head reaches a given position in the timeline. By default, the\nsource with the lowest numerical priority is displayed. Adding effects\nto a composition enables multiple sources to be composited together.\nPriority is used to determine which sources will be used by an effect as\ninput.</p>\n<h2 id=\"the-mvcobserver-design-pattern\">The MVC/Observer Design Pattern</h2>\n<p>PiTiVi relies heavily on MVC and Observer design patterns to decouple\nthe core of the application from the user interface. Core objects emit\nsignals which prompt changes in the UI. UI elements wrap core objects to\nmanipulate data, which in turn emit signals. The observer pattern allows\nthe user interface to listen for changes in the core without coupling\nthe core to the UI.</p>\n<p>In core, we have our own pure-python implementation of \u201csignals\u201d. The\nuser interface depends on pygtk and pygoocanvas, both of which are based\non GObject. We use \u201creceivers\u201d to automatically connect appropriate\nsignal handler methods to objects which emit them.</p>\n<h1 id=\"ui-framework-design\">UI Framework Design</h1>\n<p>The majority of the UI uses pygtk. The timeline portion also relies on\ngoocanvas. This section is about the pygoocanvas portion of the UI.</p>\n<p>Objects visible in the timeline will either descend from or mix-in the\nView class, available in the view module. Instances of the view class\ncreate an instance of Controller which handles low-level input events\nand translates these into higher-level commands which it passes onto the\nmodel.</p>\n<h2 id=\"views\">Views</h2>\n<p>View objects appear exclusively in the time-line component of the UI.\nEach view represents some object in the current timeline. Views must\nupdate their appearance when the object they represent changes. While in\nmost cases, this will be accomplished by connecting to model signals, it\nis up to the individual view object to do this. No infrastructure is\nprovided by the View base class. In general, views should multiply from\nView and some subclass of goocanvas.Item. The controller code connects\nto specific signals, and expects that these signals will have the same\nsignature as defined in goocanvas.Item.</p>\n<p>Views provide a public interface for controlling appearance. There are 3\nindependent visual states:</p>\n<ul>\n<li>focused/unfocused</li>\n<li>active/inactive</li>\n<li>selected/deselected.</li>\n</ul>\n<p>A fourth state, normal, is defined as being simultaneously unfocused,\ninactive, and deselected.</p>\n<h2 id=\"controllers\">Controllers</h2>\n<p>View classes have a class attribute, Controller, which can be reference\nto BaseController. Views automatically instantiate and connect to an\ninstance of this class during initialization. Derived Views can redefine\nthis attribute to any subclass of Controller -- even one defined as an\ninner class -- if they wish to override default functionality. This\ndesign is intended to keep a tight integration between a View and its\nController.</p>\n<p>Controllers provide a high-level public interface for handling the\nfollowing kinds of interaction</p>\n<ul>\n<li>key press events</li>\n<li>mouse clicks</li>\n<li>mouse drags</li>\n<li>focus changes</li>\n</ul>\n\n</div>\n\n\n\t"});