fragment_downloaded_cb({"url": "Pitivi-1.0/design/2007_design/2007_Advanced_UI_implementation.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"2007_Advanced_UI_implementation.md\">\n<h1 id=\"design-overview\">Design Overview</h1>\n<p><a href=\"image:advanced_inheritance.png.md\">Inheritance Diagram</a></p>\n<p>This document <strong>does not reflect the existing codebase</strong>, but rather a\nroad map for future development. Some of this design has been\nimplemented in the 2008_SOC_BLEWIS branch, and these changes will be\ngradually merged into trunk.</p>\n<p>The goal of the design is to build a UI which supports the following\nfeatures:</p>\n<ul>\n<li>multi-track editing</li>\n<li>multi-layer editing*</li>\n<li>multiple selection</li>\n<li>noun-verb interaction</li>\n<li>direct manipulation</li>\n<li>edge snapping</li>\n<li>multiple-level undo/redo support</li>\n</ul>\n<p>(*) It is important to distinguish between a <strong>track</strong>, and a <strong>layer</strong>\nin application terminology. Existing video editors use the term\n<strong>track</strong> to refer to a UI object which represents a stream of video\nwith a sequence of sources. PiTiVi refers to this as a <strong>composition</strong>.\nThe term <strong>track</strong> in PiTiVi means a separate channel of output: for\nexample, audio and video are in separate tracks. The Timeline class\ncontains one TimelineComposition for each of its output tracks.\nCurrently these are hard-coded to audiocomp and videocomp, but in the\nfuture multiple audio and video output tracks will be supported. This\nwill enable things like multi-language sound tracks, or multi-angle\nvideo sequences.</p>\n<p>This is distinguished from the concept of a <strong>layer</strong> which is directly\nrelated to the notion of <strong>compositing</strong>. Within a track, sources have a\nproperty called <strong>priority</strong> which determines what will appear when the\nplay-head reaches a given position in the timeline. By default, the\nsource with the lowest numerical priority is displayed. Adding effects\nto a composition enables multiple sources to be composited together.\nPriority is used to determine which sources will be used by an effect as\ninput.</p>\n<h2 id=\"the-mvcobserver-design-pattern\">The MVC/Observer Design Pattern</h2>\n<p>PiTiVi relies heavily on MVC and Observer design patterns to decouple\nthe core of the application from the user interface. Core objects emit\nsignals which prompt changes in the UI. UI elements wrap core objects to\nmanipulate data, which in turn emit signals. The observer pattern allows\nthe user interface to listen for changes in the core without coupling\nthe core to the UI.</p>\n<p>We use pygobject to provide support for the observer pattern in the\ncore. The user interface depends on pygtk and pygoocanvas, both of which\nare based on GObject.</p>\n<h2 id=\"files\">Files</h2>\n<p>The advanced UI is implemented in several files in the pitivi/ui\ndirectory in the source tree:</p>\n<ul>\n<li>util.py</li>\n<li>complexinterface.py</li>\n<li>complextimeline.py</li>\n<li>ruler.py</li>\n</ul>\n<h2 id=\"interfaces\">Interfaces</h2>\n<ul>\n<li>Selectable</li>\n<li>Draggable</li>\n<li>SelectableDraggable</li>\n<li>Magnetic</li>\n</ul>\n<h2 id=\"classes\">Classes</h2>\n<ul>\n<li>History</li>\n<li>ComplexTimelineObject\n<ul>\n<li>ComplexTimelineFile</li>\n</ul>\n</li>\n<li>Content\n<ul>\n<li>AudioContent</li>\n<li>VideoContent</li>\n</ul>\n</li>\n<li>Handle</li>\n<li>EditMarker</li>\n<li>ComplexTrack</li>\n<li>ComplexTimelineCanvas</li>\n<li>ComplexTimelineWidget</li>\n</ul>\n<h1 id=\"utilites\">Utilites</h1>\n<p>The util.py file provides a number of convenience functions for working\nwith goocanvas, including an easy way of creating canvas item objects,\nas well as generic support for drag-and-drop and selections. This file\nalso provides the SmartGroup class, which extends goocanvas.Group with\nautomatic recalculation of size and position.</p>\n<p>The code in this file is intended to be as reusable and generic as\npossible. Its goal is to overcome some limitations of goocanvas which\nmake programming dynamic, reactive interfaces more challenging than\nnecessary. Code in this file is also used by the simple timeline.</p>\n<h2 id=\"smartgroup\">SmartGroup</h2>\n<p>SmartGroup is also used to implement HList and VList, which are\ncontainer classes that enforce positioning constraints on their\nchildren. They work more-or-less like HBox and VBox in gtk. What you\nneed to know about smart group is:</p>\n<ul>\n<li>The smart group keeps track of its own position: Setting the x or y\nproperties on a smartgroup will cause all the group's children to\nmove accordingly.</li>\n<li>The smart gropu keeps track of its size: If any of the group's\nchildren change size or position, the group recomputes its width and\nheight properties.</li>\n</ul>\n<p>This is currently accomplished by using property notification signals.\nSmartGroup overrides the add_child method and connects to the\nnotify::x, notify::y, notify::width, and notify::height signals for each\nof its children.</p>\n<h2 id=\"convenience-functions\">Convenience Functions</h2>\n<p>These functions all take an item as input and return the appropriate\nproperty. They make expressions involving these properties more readable\nand more compact.</p>\n<ul>\n<li>width(item)</li>\n<li>height(item)</li>\n<li>left(item)</li>\n<li>right(item)</li>\n<li>top(item)</li>\n<li>bottom(item)</li>\n<li>center(item)</li>\n</ul>\n<p>This function handles getting coordinates from an event object and\nconverting them into the canvas space:</p>\n<ul>\n<li>event_coords(canvas, event)</li>\n</ul>\n<p>These functions manipulate object size and position</p>\n<ul>\n<li>pos(item)</li>\n<li>set_pos(item, pos), where pos is a tuple (x, y)</li>\n<li>size(item)</li>\n<li>set_size(item, size), where size is a tuple (width, height)</li>\n</ul>\n<p>These functions activate draging and selection management:</p>\n<ul>\n<li>manage_selection(canvas, changed_cb)</li>\n<li>make_selectable(canvas, item)</li>\n<li>make_dragable(canvas, item, start_cb, transform, end_cb,\nmoved_cb)</li>\n</ul>\n<h2 id=\"smartcanvas\">SmartCanvas</h2>\n<p>This class is yet to be implemented. Intended to provide internal\nsupport for some of the convenience functions described above:</p>\n<h3 id=\"methods\">Methods</h3>\n<ul>\n<li>manage_selection(), activates internal selection managment,\ndeprecates top-level function with same name</li>\n<li>make_selectable(), activates selection management on a given\nobject, deprecates top-level function with same name.</li>\n<li>make_selection_dragable(),</li>\n</ul>\n<h1 id=\"interfaces1\">Interfaces</h1>\n<p>All the interfaces used in the complex UI are kept in\ncomplexinterface.py.</p>\n<h2 id=\"zoomable\">Zoomable</h2>\n<p>This interface allows for sharing a single gtk.Adjustment among multiple\nclient objects. When the adjustment's value changes, the the Zoomable\nobject's zoomratio property is set, and its zoomChanged() method called.</p>\n<p>Implementing classes must define a zoomChanged() method. This method\nshould perform any drawing or size adjustments.</p>\n<p>Zoomable containers have the option of defining a\nsetChildZoomAdjustment() method, which they can use to set the zoom\nadjustment on all of their children. In general, however, a container\nshould set the child's zoom adjustment whenever the child is added to\nthe container.</p>\n<h2 id=\"draggable\">Draggable</h2>\n<p>This interface encapsulates handling the mouse events required to make\nan object dragable with the mouse. Objects can simply extending from\nthis interface to get basic drag-and-drop functionality. If more complex\ndrag-and-drop behavior is required, this interface provides some hook\nfunctions which can be overridden by implementing classes.</p>\n<h3 id=\"methods1\">Methods</h3>\n<ul>\n<li>dragStart -- a hook which is called to notify the object that\ndragging is about to begin</li>\n<li>dragEnd -- a hook which is called to notify the object that dragging\nhas ended</li>\n<li>dragMotion -- a hook which is called to notify the object that its\nposition should be updated.</li>\n</ul>\n<h2 id=\"selectable\">Selectable</h2>\n<p>This encapsulates the notion of an object which may be included in the\ncurrent UI selection. This is kept strictly separate from Dragable, as\nthere is a use case for selectable objects which cannot be moved by the\nuser, as well as a use case for dragable objects which should never\nbecome part of the current selection. Objects are selected with\nSelect(), and deslected with Deselect(). Objects are notified of their\nselection status through the selected() and deselected() method calls.</p>\n<p>Being part of the selection implies that the object represents data that\ncan be manipulated. To this end, all Selectable objects provide a\ncore_object property. The list of all selected core objects can be\nobtained with the getSelectedCoreObjects class method.</p>\n<p>The current selection is a set of Selectable objects, and any command\nwhich affects the current selection operates on these objects (or the\ncore objects which they represent). To facilitate this, the interface\nprovides class methods to iterate over all instances of selectable\nobjects in various ways.</p>\n<h3 id=\"properties\">Properties</h3>\n<ul>\n<li>core_object</li>\n</ul>\n<h3 id=\"methods2\">Methods</h3>\n<ul>\n<li>(absract) selected -- notifies the object it has been selected</li>\n<li>(absract) deselected -- notifies the object it has been deselected</li>\n<li>select -- places this item in the current selection</li>\n<li>deselect -- removes this item from the current selection</li>\n<li>(abstract) delete -- removes the core object from application data\nstructures</li>\n<li>(abstract) copy -- places a representation of the core object into\nthe application clipboard</li>\n<li>@classmethod getSelected -- returns a list of all selected\nselectable objects</li>\n<li>@classmethod getSelectedCoreObjects -- returns the pitivi core\nobject for every object that has been selected</li>\n<li>@classmethod deleteSelected -- deletes all selected objects</li>\n</ul>\n<h2 id=\"selectabledraggableselectable-dragable\">SelectableDraggable(Selectable, Dragable)</h2>\n<p>This is the explicit merging of the Selectable/Dragable interfaces.\nObjects which are both selectable and dragable should implement this\ninterface, rather than the two ancestors independently. The reason is\nthat this interface provides support for manipulating selections of\nmovable items: i.e., if the user has multiple items selected and moves\none of them, all the other items should move in unison.</p>\n<h3 id=\"methods3\">Methods</h3>\n<ul>\n<li>dragStart -- relays dragStart message to all other selected\nSelectableDraggable objects</li>\n<li>dragEnd -- relays dragEnd message to all other selected\nSelectableDraggable objects</li>\n<li>dragMove -- relays dragmove message to all other selected\nSelectableDraggable objects</li>\n<li>(abstract) setPos -- implemented by derived objects, sets the\nposition of the core object represented by this object</li>\n<li>@classmethod selectedDragStart</li>\n<li>@classmethod selectedDragEnd</li>\n<li>@classmethod selectedDragMove</li>\n</ul>\n<h2 id=\"magnetic\">Magnetic</h2>\n<p>Encapsulates the concept of an important point on the timeline to which\ntimestamps should be snapped during mouse operations. The class keeps\ntrack of all its instances in a sorted list, and uses binary search to\nimplement the class method snapTime(), and snapObj, which actually\nimplement magnetic edge snaping.</p>\n<h3 id=\"properties1\">Properties</h3>\n<ul>\n<li>flags -- when the control point is magnetic to the cursor, values\nare RESIZE, MOVE, RAZOR, COMMAND, ALL</li>\n</ul>\n<p>The flags property is a bit-field defining when a magnetic point will be\nused.</p>\n<ul>\n<li>RESIZE -- control point is magnetic during resize operations</li>\n<li>MOVE -- control point is magnetic during drag operations</li>\n<li>RAZOR -- control point is magnetic to razor tool, or during trimming</li>\n<li>COMMAND -- control point can be the input to a command which\noperates on current selection</li>\n<li>ALL -- equal to RESIZE | MOVE | RAZOR | COMMAND</li>\n</ul>\n<h3 id=\"methods4\">Methods</h3>\n<ul>\n<li>setTime -- update this magnet's time value</li>\n<li>@classmethod snapTime(time, flags) -- snap the input time to the\nnearest magnet according to flags</li>\n<li>@classmethod snapObj(start, duration, flags) -- snap start or end\ntime to the nearest magnet, according to flags)</li>\n</ul>\n<h1 id=\"classes1\">Classes</h1>\n<p>These classes implement the majority of the pitivi's advanced (or\ncomplex) user interface, and can be found in complextimeline.py.</p>\n<h2 id=\"history\">History</h2>\n<p>This class manages the command history for the user interface. It\nmaintains a stack of actions and their inverses.</p>\n<h3 id=\"properites\">Properites</h3>\n<ul>\n<li>undo_actions -- stack of (function, data, inverse_function,\ninverse_data) tuples</li>\n<li>redo_actions -- stack of (function, data, inverse_function,\ninverse_data) tuples</li>\n</ul>\n<h3 id=\"methods5\">Methods</h3>\n<ul>\n<li>undoLast -- pop the top of the undo stack, push onto the redo stack\nand execute the inverse operation</li>\n<li>redoLast -- pop the redo stack, push the undo stack, and execute the\nnon-inverse operation</li>\n<li>pushAction -- add a new tuple to the top of the history stack.</li>\n<li>peek -- return the top of the undo stack</li>\n<li>poke -- update the top of the undo stack in place</li>\n<li>pop -- pop from the undo stack without performing any action or\npushing the redo stack (for example, to clear a canceled operation\nfrom the undo stack)</li>\n<li>clear -- clears the undo/redo stack</li>\n</ul>\n<h2 id=\"complextimelinewidgetgtkhbox\">ComplexTimelineWidget(gtk.HBox)</h2>\n<p>This widget contains the timeline canvas and the ruler. It is also\nresponsible for showing and hiding toolbar actions associated with the\ncomplex timeline.</p>\n<h2 id=\"complextimelinecanvasgoocanvascanvas-zoomable\">ComplexTimelineCanvas(goocanvas.Canvas, Zoomable)</h2>\n<p>(currently called ComplexLayers, will be renamed before the next\nrelease)</p>\n<p>This class <em>is</em> the timeline. The canvas creates one ComplexTrack item\nfor ComplexTrack item for each top-level composition within a timeline.\nPiTiVi core doesn't yet support multi-track editing, but this support is\nplanned. ComplexTracks should be able to handle creating/destroying\ntracks dynamically.</p>\n<p>In addition to the timeline itself, this widget keeps track of a number\nof important details about the timeline: current edit points, playhead\nposition, current tool (only razor or pointer, at present), and the\ncurrent selection.</p>\n<p>Mouse and pointer events received by this widget are routed to the\nselection or the current active tool. Keyboard events are handled here\ndirectly depending on the current active tool.</p>\n<h3 id=\"the-selection\">The Selection</h3>\n<p>The primary goal of the editing canvas is to allow the user to modify\nthe selection as they see fit, and then apply changes to the selected\nobject. The selection consists of a set of objects implementing the\nSelectable interface.</p>\n<p>The canvas keeps track of whether or not objects are selected. Objects\nin the timeline always pass pointer events up to their parent group. If\nan event reaches the root item group, a test is performed to determine\nif the object should be added to the current selection. If this test\npasses, the objects select() method is called.</p>\n<p>The selection also identifies a primary object: this is the object with\nwhich the user is directly interacting with, i.e. the source of the\npointer event. Certain operations make the most sense in the context of\na single active object. For example, if the user selects several sources\nand then drags one of them, this object will be used as a reference\npoint for edge snapping.</p>\n<p>Finally, the user is provided with a few tool-bar commands which\nmanipulate the selection explicitly.</p>\n<h3 id=\"selection-management-methods\">Selection Management Methods</h3>\n<ul>\n<li>deleteSelected()</li>\n<li>copySelected()</li>\n<li>moveSelected()</li>\n<li>clearSelection()</li>\n<li>selectBeforeCurrent()</li>\n<li>selectAfterCurrent()</li>\n</ul>\n<h3 id=\"selection-manipulation-methods\">Selection Manipulation Methods</h3>\n<ul>\n<li>copySelected()</li>\n<li>deleteSelected()</li>\n<li>moveSelected()</li>\n<li>linkSelected()</li>\n<li>unlinkSelected()</li>\n<li>collapseSelected()</li>\n</ul>\n<p>Commands which operate on the selection are sent to this widget, which\niterates over the selection and performs operations on every element\ncontained therein.</p>\n<h3 id=\"other\">Other</h3>\n<ul>\n<li>activateRazor()</li>\n<li>deactivateRazor()</li>\n</ul>\n<h2 id=\"complextracksmartgroup-zoomable\">ComplexTrack(SmartGroup, Zoomable)</h2>\n<p>This class is a container for pitivi tracks.</p>\n<ul>\n<li>Time is represented by horizontal position, in proportion to the\ncurrent zoom ratio</li>\n<li>Priority is represented by vertical position, with the top of the\ncanvas representing the highest priority.</li>\n</ul>\n<p>This class encapsulates an internal view of a TimelineComposition\nobject. Each ComplexTrack manages exactly one TimelineComposition, and\nconnects to the following signals:</p>\n<ul>\n<li>source-added</li>\n<li>source-removed</li>\n<li>effect-added</li>\n<li>effect-removed</li>\n<li>transition-added</li>\n<li>transition-removed</li>\n</ul>\n<p>These signals are all sent to the same pair of signal handlers,\n_objectAdded, _objectRemoved, respectively. This function takes an\nadditional parameter, klass, which is a reference to the sublclass of\nComplexTimelineObject which should be instantiated.</p>\n<h2 id=\"handlerect-dragable-magnetic\">Handle(Rect, Dragable, Magnetic)</h2>\n<p>This object is used by ComplexTimelineObject to represent the in/out\nedit points of the object. A handle is a goocanvas.Rect item which\nimplements the Dragable, and Magnetic interfaces. It is not directly\nselectable. A handle object does not directly set its position, but\ninstead hands off mouse events to a callback function, motion_callback.</p>\n<h3 id=\"properties2\">Properties</h3>\n<ul>\n<li>width</li>\n<li>height</li>\n<li>active_color</li>\n<li>normal_color</li>\n<li>motion_callback</li>\n<li>cursor</li>\n</ul>\n<h3 id=\"methods6\">Methods</h3>\n<ul>\n<li>__init__ -- sets up initial properties, and stores the\nmotion_callback</li>\n<li>dragBegin -- sets item's color to the active color</li>\n<li>dragEnd -- sets item to the the normal color, updates magnet\ntimestamp</li>\n<li>dragMotion -- calls the motion_callback, after performing some\ntransformations</li>\n</ul>\n<h2 id=\"complextimelineobjectgroup-zoomable-selectabledragable\">ComplexTimelineObject(Group, Zoomable, SelectableDragable)</h2>\n<p>Corresponds to pitivi.timeline.objects.TimelineObject. It is a base\nclass for all objects represented in the ComplexTimeline. When created,\nit is given a reference to a TimelineObject, and connects to that\nobject's <code>start-duration-changed</code> signal. When the core object's start\nand duration change, the UI object's horizontal position and width are\nupdated. When the core object's layer position changes, the vertical\nposition is updated.</p>\n<p>Every TimelineObject has a reference to a Content object which is\ndisplayed inside of the TimelineObject. This object may be audio or\nvideo. The Content object can change height or visibility depending on\nits state. The parent ComplexTimelineObject must keep track of the\nheight of its content region and adjust its height accordingly.</p>\n<p>ComplexTimelineObjects have drag handles which allow them to be directly\nresized. See the Handle class documentation for more information.</p>\n<h3 id=\"properties3\">Properties</h3>\n<ul>\n<li>background -- background rectangle</li>\n<li>coreobject -- the core PiTiVi object which this timelineobject\nrepresents</li>\n<li>content -- Content object</li>\n<li>inpoint -- Handle, representing the in point of the source</li>\n<li>outpoint -- Handle, representing the out point of the source</li>\n</ul>\n<h3 id=\"methods7\">Methods</h3>\n<ul>\n<li>dragMotion -- calls setStartPoint, Magnetic.snapTime(), and\nselectable.dragMotion() to adjust the object's position.</li>\n<li>(private) startDurationChanged -- handler for the coreobject's\nstart-duration-changed signal</li>\n<li>setStartPoint -- sets coreobject's start property</li>\n<li>setInPoint -- callback given to inpoint as its motion callback,\nwhich sets coreobject's start/duration properties</li>\n<li>setOutPoint -- callback given to outpoint as its motion callback\nwhich sets coreobject's duration property</li>\n</ul>\n<h2 id=\"timelinefileobjecttimelineobject\">TimelineFileObject(TimelineObject)</h2>\n<p>This class derives from TimelineObject. It overrides the signal handlers\nwhich set the in/out edit points so that they also set the\nmedia-start/media-duration points.</p>\n<h3 id=\"methods8\">Methods</h3>\n<ul>\n<li>setInPoint</li>\n<li>setOutPoint</li>\n</ul>\n<h2 id=\"contentsmartgroup\">Content(Smartgroup)</h2>\n<p>Abstract base class for the content region of ComplexTimelineObject. The\ncontent region displays a representation of the core object associated\nwith the Content object's parent ComplexTimelineObject. Content regions\nmay be expanded, contracted, or minimized. When expanded, the full\npreview image is visible, and the widget is expanded to maximum height\nso that the keyframe editor can be used. When contracted, only the\npreview image is visible. When minimized, the content region is\ncompletely hidden.</p>\n<h3 id=\"properties4\">Properties</h3>\n<ul>\n<li>width</li>\n<li>height</li>\n<li>name</li>\n<li>content_image</li>\n<li>keyframes</li>\n<li>coreobject</li>\n</ul>\n<h3 id=\"methods9\">Methods</h3>\n<ul>\n<li>expand()</li>\n<li>contract()</li>\n<li>minimize()</li>\n<li>make_content_image -- creates a generic image thumbnail.</li>\n</ul>\n<h2 id=\"audiocontentcontent\">AudioContent(Content)</h2>\n<p>Overrides make_content_image to create an audio waveform from audio\nstream data.</p>\n<h3 id=\"methods10\">Methods</h3>\n<ul>\n<li>make_content_image</li>\n</ul>\n<h2 id=\"videocontentcontent\">VideoContent(Content)</h2>\n<p>Overrides make_content_image to create a thumbnail sequence.</p>\n<h3 id=\"methods11\">Methods</h3>\n<ul>\n<li>make_content_image</li>\n</ul>\n<h2 id=\"markergoocanvaspolygon-selectabledragable-magnetic\">Marker(goocanvas.Polygon, SelectableDragable, Magnetic)</h2>\n<p>Similar to a handle, but can be the selected, which implies that it\ncontains a reference to a core object.</p>\n<h2 id=\"scalerulergtklayout-zoomable\">ScaleRuler(gtk.Layout, Zoomable)</h2>\n<p>This file contains the ScaleRuler class, a zoomable timeline ruler. It\nshould share the same gtk.Adjustment objects for both zooming and\nhorizontal scrolling.</p>\n\n</div>\n\n\n\t"});