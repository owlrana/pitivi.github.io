fragment_downloaded_cb({"url": "Pitivi-1.0/Roadmap.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"Roadmap.md\">\n<h1 id=\"roadmap\">Roadmap</h1>\n<p>This is intended to be a <strong>general overview</strong> of the very\nimportant or big features/improvements we are working on, or planning.\nFor a list of smaller features see <a href=\"https://phabricator.freedesktop.org/project/view/111/\">fun tasks for\nnewcomers</a>.</p>\n<p>What keeps us busy in general?</p>\n<ul>\n<li><strong>Fixing bugs</strong>. Improving reliability and ease of use is never\n\u201cdone\u201d. We have\n<a href=\"https://phabricator.freedesktop.org/tag/pitivi/\">tons</a> of work.\n<a href=\"http://www.Pitivi.org/?go=contributing\">Help</a> is very welcome!</li>\n<li><strong>Improving GStreamer</strong>. This benefits not only Pitivi, but other\nmultimedia applications as well.</li>\n<li><strong>Working on features</strong>: Until we reach <a href=\"releases/1.0.html\">1.0</a>, only\nif they improve stability.</li>\n</ul>\n<h1 id=\"highlevel-roadmap\">High-level roadmap</h1>\n<p>Any time estimates here are mostly wild guesses. Do not treat them as\nhard deadlines. This aims mostly at giving an idea of how milestones\nfollow each other.</p>\n<ul>\n<li>2016 Q2: release <a href=\"releases/0.96.html\">0.96</a> with a focus on\nstabilization and accuracy through proxy files</li>\n<li>2016 Q4 or 2017 Q2: release <a href=\"releases/1.0.html\">1.0</a> with ponies and\nrainbows</li>\n</ul>\n<p>See <a href=\"Current_events.html\">Current events</a> for past items.</p>\n<h1 id=\"major-features\">Major features</h1>\n<h2 id=\"plugin-system\">Plugin system</h2>\n<ul>\n<li>Status: planning.</li>\n<li><strong>This is very important</strong>. A plugin would have access to the entire\napp. Being in Python, it will be extremely easy to quickly write\nuseful plugins without having to compile anything. Pitivi plugins\nwill allow manipulating the timeline clips and clip effects\nautomatically, thus allowing great flexibility for custom solutions.\nSee the <a href=\"https://phabricator.freedesktop.org/T3193\">tasks blocked by\nT3193</a> for a few examples\nwhere this will be useful.</li>\n</ul>\n<h2 id=\"motion-rampingtime-stretching\">Motion ramping/time stretching</h2>\n<ul>\n<li>Status: started</li>\n<li>See <a href=\"https://phabricator.freedesktop.org/T2344\">T2344</a></li>\n</ul>\n<h2 id=\"effects\">Effects</h2>\n<ul>\n<li>We need to create custom (\u201chand-made\u201d) interfaces for some effects\nso that they can be easier to use. See\n<a href=\"https://phabricator.freedesktop.org/T3263\">T3263</a></li>\n</ul>\n<h2 id=\"advanced-layer-management\">Advanced layer management</h2>\n<ul>\n<li>See <a href=\"https://phabricator.freedesktop.org/T2642#85395\">T2642</a></li>\n</ul>\n<h2 id=\"a-better-title-editor\">A better title editor</h2>\n<ul>\n<li>The current title editor UI is very simple. Please join us to make\nit work up to your expectations! See the existing\n[<a href=\"https://phabricator.freedesktop.org/maniphest/?statuses=open\">https://phabricator.freedesktop.org/maniphest/?statuses=open</a>()&amp;projects=PHID-PROJ-ext-TITLEEDITOR#R\ntitle editor tasks].</li>\n</ul>\n<h2 id=\"mamdam\">MAM/DAM</h2>\n<ul>\n<li><a href=\"http://en.wikipedia.org/wiki/Digital_asset_management\">Digital asset\nmanagement</a>\nis the ability to manage huge amounts of media (video clips, sounds,\nimages, etc.). This feature is very much needed for professional\nediting; it allows handling multiple simultaneous camera angles,\nmultiple takes of the same scene, multiple sound sources, etc.</li>\n<li>Potentially being addressed by the Novacut team with\n<a href=\"https://launchpad.net/dmedia\">dmedia</a></li>\n</ul>\n<h2 id=\"hardwareaccelerated-decoding-and-encoding\">Hardware-accelerated decoding and encoding</h2>\n<ul>\n<li>Since GStreamer 1.2, the basic infrastructure allowing us to cleanly\ntake advantage of the video decoding capabilities of modern graphic\ncards is there. We need to ensure that our planned usecases are\nproperly supported with the most common graphic drivers (through\nVA-API) and to make the integration work in Pitivi.</li>\n</ul>\n<h2 id=\"proxy-editing\">Proxy editing</h2>\n<ul>\n<li>See <a href=\"design/Proxy_editing_requirements.html\">proxy editing\nrequirements</a> for the \u201cspec\u201d\nof how this feature should behave</li>\n<li>See <a href=\"https://phabricator.freedesktop.org/T2455\">T2455</a></li>\n</ul>\n<h1 id=\"proxy-editing-requirements\">Proxy editing requirements</h1>\n<p>See <a href=\"https://phabricator.freedesktop.org/T2455\">T2455</a> to learn about\nproxy editing and why we want this in <a href=\"GES.html\">GES</a> and Pitivi.\nThis page is meant to brainstorm:</p>\n<ul>\n<li>User interface/user experience (UX) possibilities and requirements</li>\n<li>GES API requirements deriving from that. This also touches on media\nassets management in general.</li>\n</ul>\n<p>Prior art if you don't know what proxy editing \u201cfeels\u201d like:</p>\n<ul>\n<li><a href=\"http://www.youtube.com/watch?v=SyUvp0YqLpc\">In Edius</a>. This is an\ninteresting example of a badly designed UI: pretty much all the\noptions/preferences presented there are useless, the application\nshould be smart enough to make those choices!</li>\n<li><a href=\"http://www.youtube.com/watch?v=MnZx3JxoR-A\">In FCP X</a> (alternative\n<a href=\"http://www.youtube.com/watch?v=aL7gE-my4_c\">longer version</a>)</li>\n<li><a href=\"http://www.youtube.com/watch?v=4PE6tDjgDEY\">In Sony Vegas</a></li>\n<li>Others we should be looking at in particular? Some particularly\ngreat (short and to the point) video tutorials of other apps we\nought to see? Let us know.</li>\n</ul>\n<h1 id=\"user-experience\">User experience</h1>\n<p>As <a href=\"https://phabricator.freedesktop.org/T2455\">T2455</a> indicates, we can\nenvision two types of user experience: a semi-automatic and a\nfully-automated one. Since Pitivi is not the only application (now and\nin the future) using GES, we need to design the GES API to be flexible\nenough to accomodate the design needs of both kinds of applications.</p>\n<p>In both cases, the experience must be:</p>\n<ul>\n<li>Intuitive: it should be a very easily discoverable feature</li>\n<li>With good visual indications of the process and progress. We should\nprobably have some sort of \u201cyellow/green light\u201d (red for errors)\nicons somewhere near each clip in the media library to indicate the\nstatus of individual proxies. Remains to be seen how we can do this\nwith iconview mode and listview mode without going insane.</li>\n<li>Fluid, with no negative performance impacts from the act of\ngenerating the clip \u201cproxies\u201d</li>\n</ul>\n<h2 id=\"icons-representation\">Icons representation</h2>\n<p>Since the Media Library's iconview is meant to be compact and\nminimalistic (and has a fair amount of technical limitations), we could\nuse the following icon metaphor system to indicate the states of proxies\nfor assets:</p>\n<p>Status icon   Icon's opacity   Thumbnail's opacity   Meaning</p>\n<hr>\n<p>None          N/A              100%                  Proxies are disabled for this asset\nGears/sync?   100%             50%                   A proxy is currently being generated for this asset\nCheckmark     70%?             100%                  Proxies are present and ready for this asset\n\u26a0 (warning)   100%             100%                  The proxy could not be generated for this asset\n\u26a0 or X        100%             50%                   A proxy file is present, but the original file is absent</p>\n<h2 id=\"manualsemiautomated-ux\">Manual/semi-automated UX</h2>\n<p>In this mode, users would manually select which assets/clips use\nproxies, and when the proxies are generated. There would be no\n\u201cautomated\u201d background processing. This is probably not what we want in\nPitivi in terms of the default user experience, however the GES API\nshould support that scenario. We could still provide this feature in\npitivi by:</p>\n<ol>\n<li>Having an option in the preferences, under the \u201cPerformance\u201d\nsection: \u201cAutomatically create proxies for clips in the media\nlibrary\u201d</li>\n<li>If that option is disabled, show a toolbar button in the media\nlibrary that, when clicked, generates the proxies for selected\nclips.</li>\n</ol>\n<p>However this also means temporarily providing a \u201cCancel\u201d button while\nthose clips' proxies are being generated. Additionally to the \u201cstatus\nlights\u201d icons mentioned earlier, we could perhaps show a progressbar\n(with a \u201cStop\u201d button on its right) below the media library (similar to\nwhen we're importing clips).</p>\n<p>Jakub commented:</p>\n<blockquote>\n<p>\u201cSemi-automatic - I don't grok this experience. Why would I want to\nexplicitly hold the burden of being a transcoding manager? I like the\nvalidity checking and ability to explicitly re-render a proxy though.\nRan into issues in both kdenlive and FCPX where I spent ages looking\nfor a faulty proxy.\u201d</p>\n</blockquote>\n<p>To balance things, Bassam commented:</p>\n<blockquote>\n<p>\"manual vs. automatic: however the ui is chosen, this should be a per\nproject setting, not a choice of a different application. both\nworkflows are valid, and the same person might opt for one or another\ndepending on the specifics of the project. [...]</p>\n</blockquote>\n<h2 id=\"fullyautomated-ux\">Fully-automated UX</h2>\n<p>Otherwise, the default behavior would be to transparently (and\nintelligently) create proxies for everything, in the background. When a\nproxy file does not exist for an asset (clip), create it and use it as\nsoon as it has been created.</p>\n<p>Performance requirements in the automated scenario are even more\nimportant than in the semi-automated scenario; while users can expect\nsome delay (as long as there is a visual progress indication) when they\nmanually trigger an action, they must absolutely <em>not</em> feel\ndelays/sluggishness when such actions are triggered automatically. The\ngeneration of proxy clips in the background should not negatively impact\nsystem performance.</p>\n<p>Jakub has a different opinion than Jeff's or Bassam's, suggesting (?)\nthat we make proxy generation a modal (blocking, in terms of UI)\noperation:</p>\n<blockquote>\n<p>\"You mention the problem of indicating the transcoding process as if\nyou could continue working with original assets and have that not stop\nyou from editing work with original media. In case of offline editing\n(either having assets on external drive, or networked/cloud storage),\nthe indication can be summed up to \u201ctell me when my assets are safe to\ndisconnect and I'm able to proceed editing offline\u201d. For low\nperforming systems, the background transcoding is just an illusion,\nyou cannot really edit until your assets are transcoded. So I think\nboth cases are best addressed by providing an aggregate progressbar\ntelling me when all assets referenced from the project are transcoded,\nrather than colorcoding individual clips, or worrying about preview\noverlays. [...] For offline editing I would agree not choking the\nsystem competely with transcoding might be a good thing, but for the\nlow performing system case you want the transcoding process to take\nthe foreground so that the assets are ready sooner. You really can't\ndo any 4k editing on a laptop and expect to also transcode proxies in\nthe background.\"</p>\n</blockquote>\n<h1 id=\"ges-api-requirements\">GES API requirements</h1>\n<h2 id=\"control\">Control</h2>\n<ul>\n<li>Proxies generation/processing needs to be pause-able\n<ul>\n<li>When pitivi starts playback (or render) and needs the system's\nresources</li>\n<li>When the user pauses proxy generation (in the case of the\nsemi-automated UX)</li>\n</ul>\n</li>\n<li>Proxies generation needs to be cancel-able\n<ul>\n<li>When the user asks to stop generating proxies for selected clips\n(in the case of the semi-automated UX)</li>\n</ul>\n</li>\n<li>The ability to \u201cforce\u201d regenerating the proxies for a given asset\n(for whatever reason)</li>\n<li>Delete a proxy (or all proxies) for a given asset</li>\n<li>Relocate/move proxies for a given asset or for all assets</li>\n<li>Ability to manually replace an offline asset.</li>\n</ul>\n<h2 id=\"data-integrity-checking\">Data integrity checking</h2>\n<ul>\n<li>Need a way to detect incomplete or invalid proxies, to handle\nvarious scenarios:\n<ul>\n<li>The user has quit the application before it was done processing</li>\n<li>The application crashed</li>\n<li>The source file has changed (use a md5 on the first few bytes of\nthe file like in pitivi/previewers.py and store that hash in the\nGES Asset?)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"signallingnotifying\">Signalling/notifying</h2>\n<ul>\n<li>For each asset, report the proxies' encoding progress, so the\napplication UI can show progressbars or some other form of visual\nindications</li>\n<li>Provide a way to signal to the application that an asset has its\noriginal offline, or its proxy offline, or whatever situation we can\nimagine, so the UI can let the user know about it.</li>\n<li>Tolerate and signal errors/failures.</li>\n</ul>\n<h2 id=\"fault-tolerance-and-sandboxing\">Fault tolerance and sandboxing</h2>\n<ul>\n<li>Tolerate and signal errors/failures.</li>\n<li>Processing should probably happen in a separate/sandboxed process,\nto ensure that GES/applications can't crash because of something\ngoing wrong during the processing of a proxy</li>\n<li>GES needs to handle the notion that an asset and/or any of its\nproxies can go offline/online. For example, if the original clip is\nnot available but the proxy version is present, consider the\noriginal \u201coffline\u201d and use the proxy version.\n<ul>\n<li>The way we handle \u201cmissing\u201d media needs to change: currently\nPitivi just refuses to handle \u201cpartial\u201d projects, but in theory\nit should \u201cdeal with it\u201d. Even if all the assets of a clip\n(including proxies) are offline.</li>\n<li>If an asset or its proxies were moved/renamed externally, allow\nspecifying the new location (already mostly implemented in GES\nassets?), but don't force it. Proxies/assets for which the user\nhas not provided replacements are to be marked as temporarily\n\u201coffline\u201d (we should also save info about the last time it was\nseen, its metadata/attributes, etc.).</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"additional-api-flexibility\">Additional API flexibility</h2>\n<ul>\n<li>Multiple ways to handle offline assets for rendering and export:\n<ul>\n<li>\u201cDraft render\u201d mode (low quality render using only the proxies\ninstead of the original clips), as some applications might like\nto offer that feature.</li>\n<li>Rendering to a multimedia output file requires original assets\nto be \u201conline\u201d. Otherwise, if only proxies are available, we\ncan:\n<ul>\n<li>Warn the user about reduced quality. If some assets have no\noriginals and no proxies, show a serious warning.</li>\n<li>Export only an EDL (edit decision list), but that's <a href=\"https://bugzilla.gnome.org/show_bug.cgi?id=674605\">another\nstory</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Provide a way to specify which containers, codecs and settings (ex:\nvideo resolution, bitrate/quality) to use for proxies. This will\nprobably use a technology similar to what we see in Pitivi's render\ndialogs.</li>\n<li>Allow multiple proxies per asset (for multiple resolutions, for\nexample). The application should be able to request a proxy to match\na particular context (ex: a maximum resolution or something); for\nexample, multicam editing could use very small versions if there is\na big number (ex: 16) of camera angles to be displayed\nsimultaneously. Or the media library could automatically show a\nplaying thumbnail-sized video preview when putting the mouse over a\nclip.</li>\n<li>Ability to save, in a project formatter's data, the following\nper-project overrides of the global app settings:\n<ul>\n<li>A custom folder path for the proxies for that project (see also\nthe \u201cwhere to store the proxies?\u201d item in the \u201coutstanding\nquestions\u201d section on this page).</li>\n<li>Whether this project prefers fully-automated (or manual)\nhandling of proxies (Bassam said: \u201cHowever the ui is chosen,\nthis should be a per project setting, not a choice of a\ndifferent application. Both workflows are valid, and the same\nperson might opt for one or another depending on the specifics\nof the project.\u201d)</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"outstanding-questions\">Outstanding questions</h1>\n<ul>\n<li>Where to store the proxies? (beyond the obvious question of disk\nspace and tidiness, there's the question of people working across\nnetworks that raises interesting questions)\n<ul>\n<li>In pitivi we could default to the XDG user cache dir (which in\nthis case would turn out to be ~/.cache/pitivi/proxies/)</li>\n<li>...but Bassam insists that this can be overridden on a\nper-project basis. So in the project settings UI, we could have\na checkbox to \u201cUse a custom directory to store proxies\u201d that\nenables a gtk folder chooser button right besides it. Unchecking\nthe checkbox would clear the project's custom directory.</li>\n</ul>\n</li>\n<li>Filenames of the actual proxy files depending on their location\n(global cache folder vs project folder?). For example, if a clip is\ncalled \u201cfoo.MOV\u201d, should the proxies be called foo-360p.gesproxy, or\nfoo--proxy-360p.webm, or C462NTH353.webm in the hidden cache folder,\nor...?</li>\n<li>Codecs? So far we're hesitating between MJPEG and VP8. MJPEG is\nhandsdown the fastest codec to seek and to encode, since it is so\nsimple and every frame is a keyframe - however, the filesize is\nrather big. VP8 is more configurable and can be made to approximate\nMJPEG's seeking performance, but it is significantly more expensive\nto encode.</li>\n<li>Resolutions, and how to handle aspect ratios. That is, how do you\ndetermine the appropriate resolution depending on the aspect ratio\nand resolution of the source material?\n<ul>\n<li>Going with a hardcoded percentage (ex: 50% of the original's\nresolution) can be bound to fail in scenarios where the original\nhas a huge native resolution (such as 4K).</li>\n<li>Alternatively, one can imagine a hardcoded (or configurable)\n\u201cmax resolution\u201d, where clips bigger than that resolution will\nhave proxies created to \u201cfit the box\u201d (in terms of width and\nheight, whichever comes first). Hardcoding the box resolution\nmight be problematic as computers become more powerful and\nscreen resolutions increase.</li>\n<li>Ideally, we need a clever algorithm to figure out all of this\nautomatically. Any rough ideas of the logic here? Let us know.\nSolutions where the software can be smart enough to figure the\noptimal resolution to use, instead of having the user deal with\nit, are preferred.</li>\n</ul>\n</li>\n<li>Handling \u201ctarball export\u201d in Pitivi</li>\n</ul>\n\n</div>\n\n\n\t"});