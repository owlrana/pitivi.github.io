fragment_downloaded_cb({"url":"design/2007_design/2007_Advanced_UI_implementation.html#page-description","fragment":"\nThis document does not reflect the existing codebase, but rather a\nroad map for future development. Some of this design has been\nimplemented in the 2008_SOC_BLEWIS branch, and these changes will be\ngradually merged into trunk.\nThe goal of the design is to build a UI which supports the following\nfeatures:\n(*) It is important to distinguish between a track, and a layer\nin application terminology. Existing video editors use the term\ntrack to refer to a UI object which represents a stream of video\nwith a sequence of sources. PiTiVi refers to this as a composition.\nThe term track in PiTiVi means a separate channel of output: for\nexample, audio and video are in separate tracks. The Timeline class\ncontains one TimelineComposition for each of its output tracks.\nCurrently these are hard-coded to audiocomp and videocomp, but in the\nfuture multiple audio and video output tracks will be supported. This\nwill enable things like multi-language sound tracks, or multi-angle\nvideo sequences.\nThis is distinguished from the concept of a layer which is directly\nrelated to the notion of compositing. Within a track, sources have a\nproperty called priority which determines what will appear when the\nplay-head reaches a given position in the timeline. By default, the\nsource with the lowest numerical priority is displayed. Adding effects\nto a composition enables multiple sources to be composited together.\nPriority is used to determine which sources will be used by an effect as\ninput.\nPiTiVi relies heavily on MVC and Observer design patterns to decouple\nthe core of the application from the user interface. Core objects emit\nsignals which prompt changes in the UI. UI elements wrap core objects to\nmanipulate data, which in turn emit signals. The observer pattern allows\nthe user interface to listen for changes in the core without coupling\nthe core to the UI.\nWe use pygobject to provide support for the observer pattern in the\ncore. The user interface depends on pygtk and pygoocanvas, both of which\nare based on GObject.\nThe advanced UI is implemented in several files in the pitivi/ui\ndirectory in the source tree:\nThe util.py file provides a number of convenience functions for working\nwith goocanvas, including an easy way of creating canvas item objects,\nas well as generic support for drag-and-drop and selections. This file\nalso provides the SmartGroup class, which extends goocanvas.Group with\nautomatic recalculation of size and position.\nThe code in this file is intended to be as reusable and generic as\npossible. Its goal is to overcome some limitations of goocanvas which\nmake programming dynamic, reactive interfaces more challenging than\nnecessary. Code in this file is also used by the simple timeline.\nSmartGroup is also used to implement HList and VList, which are\ncontainer classes that enforce positioning constraints on their\nchildren. They work more-or-less like HBox and VBox in gtk. What you\nneed to know about smart group is:\nThis is currently accomplished by using property notification signals.\nSmartGroup overrides the add_child method and connects to the\nnotify::x, notify::y, notify::width, and notify::height signals for each\nof its children.\nThese functions all take an item as input and return the appropriate\nproperty. They make expressions involving these properties more readable\nand more compact.\nThis function handles getting coordinates from an event object and\nconverting them into the canvas space:\nThese functions manipulate object size and position\nThese functions activate dragging and selection management:\nThis class is yet to be implemented. Intended to provide internal\nsupport for some of the convenience functions described above:\nAll the interfaces used in the complex UI are kept in\ncomplexinterface.py.\nThis interface allows for sharing a single gtk.Adjustment among multiple\nclient objects. When the adjustment's value changes, the the Zoomable\nobject's zoomratio property is set, and its zoomChanged() method called.\nImplementing classes must define a zoomChanged() method. This method\nshould perform any drawing or size adjustments.\nZoomable containers have the option of defining a\nsetChildZoomAdjustment() method, which they can use to set the zoom\nadjustment on all of their children. In general, however, a container\nshould set the child's zoom adjustment whenever the child is added to\nthe container.\nThis interface encapsulates handling the mouse events required to make\nan object dragable with the mouse. Objects can simply extending from\nthis interface to get basic drag-and-drop functionality. If more complex\ndrag-and-drop behavior is required, this interface provides some hook\nfunctions which can be overridden by implementing classes.\nThis encapsulates the notion of an object which may be included in the\ncurrent UI selection. This is kept strictly separate from Dragable, as\nthere is a use case for selectable objects which cannot be moved by the\nuser, as well as a use case for dragable objects which should never\nbecome part of the current selection. Objects are selected with\nSelect(), and deselected with Deselect(). Objects are notified of their\nselection status through the selected() and deselected() method calls.\nBeing part of the selection implies that the object represents data that\ncan be manipulated. To this end, all Selectable objects provide a\ncore_object property. The list of all selected core objects can be\nobtained with the getSelectedCoreObjects class method.\nThe current selection is a set of Selectable objects, and any command\nwhich affects the current selection operates on these objects (or the\ncore objects which they represent). To facilitate this, the interface\nprovides class methods to iterate over all instances of selectable\nobjects in various ways.\nThis is the explicit merging of the Selectable/Dragable interfaces.\nObjects which are both selectable and dragable should implement this\ninterface, rather than the two ancestors independently. The reason is\nthat this interface provides support for manipulating selections of\nmovable items: i.e., if the user has multiple items selected and moves\none of them, all the other items should move in unison.\nEncapsulates the concept of an important point on the timeline to which\ntimestamps should be snapped during mouse operations. The class keeps\ntrack of all its instances in a sorted list, and uses binary search to\nimplement the class method snapTime(), and snapObj, which actually\nimplement magnetic edge snapping.\nThe flags property is a bit-field defining when a magnetic point will be\nused.\nThese classes implement the majority of the pitivi's advanced (or\ncomplex) user interface, and can be found in complextimeline.py.\nThis class manages the command history for the user interface. It\nmaintains a stack of actions and their inverses.\nThis widget contains the timeline canvas and the ruler. It is also\nresponsible for showing and hiding toolbar actions associated with the\ncomplex timeline.\n(currently called ComplexLayers, will be renamed before the next\nrelease)\nThis class is the timeline. The canvas creates one ComplexTrack item\nfor ComplexTrack item for each top-level composition within a timeline.\nPiTiVi core doesn't yet support multi-track editing, but this support is\nplanned. ComplexTracks should be able to handle creating/destroying\ntracks dynamically.\nIn addition to the timeline itself, this widget keeps track of a number\nof important details about the timeline: current edit points, playhead\nposition, current tool (only razor or pointer, at present), and the\ncurrent selection.\nMouse and pointer events received by this widget are routed to the\nselection or the current active tool. Keyboard events are handled here\ndirectly depending on the current active tool.\nThe primary goal of the editing canvas is to allow the user to modify\nthe selection as they see fit, and then apply changes to the selected\nobject. The selection consists of a set of objects implementing the\nSelectable interface.\nThe canvas keeps track of whether or not objects are selected. Objects\nin the timeline always pass pointer events up to their parent group. If\nan event reaches the root item group, a test is performed to determine\nif the object should be added to the current selection. If this test\npasses, the objects select() method is called.\nThe selection also identifies a primary object: this is the object with\nwhich the user is directly interacting with, i.e. the source of the\npointer event. Certain operations make the most sense in the context of\na single active object. For example, if the user selects several sources\nand then drags one of them, this object will be used as a reference\npoint for edge snapping.\nFinally, the user is provided with a few tool-bar commands which\nmanipulate the selection explicitly.\nCommands which operate on the selection are sent to this widget, which\niterates over the selection and performs operations on every element\ncontained therein.\nThis class is a container for pitivi tracks.\nThis class encapsulates an internal view of a TimelineComposition\nobject. Each ComplexTrack manages exactly one TimelineComposition, and\nconnects to the following signals:\nThese signals are all sent to the same pair of signal handlers,\n_objectAdded, _objectRemoved, respectively. This function takes an\nadditional parameter, klass, which is a reference to the sublclass of\nComplexTimelineObject which should be instantiated.\nThis object is used by ComplexTimelineObject to represent the in/out\nedit points of the object. A handle is a goocanvas.Rect item which\nimplements the Dragable, and Magnetic interfaces. It is not directly\nselectable. A handle object does not directly set its position, but\ninstead hands off mouse events to a callback function, motion_callback.\nCorresponds to pitivi.timeline.objects.TimelineObject. It is a base\nclass for all objects represented in the ComplexTimeline. When created,\nit is given a reference to a TimelineObject, and connects to that\nobject's start-duration-changed signal. When the core object's start\nand duration change, the UI object's horizontal position and width are\nupdated. When the core object's layer position changes, the vertical\nposition is updated.\nEvery TimelineObject has a reference to a Content object which is\ndisplayed inside of the TimelineObject. This object may be audio or\nvideo. The Content object can change height or visibility depending on\nits state. The parent ComplexTimelineObject must keep track of the\nheight of its content region and adjust its height accordingly.\nComplexTimelineObjects have drag handles which allow them to be directly\nresized. See the Handle class documentation for more information.\nThis class derives from TimelineObject. It overrides the signal handlers\nwhich set the in/out edit points so that they also set the\nmedia-start/media-duration points.\nAbstract base class for the content region of ComplexTimelineObject. The\ncontent region displays a representation of the core object associated\nwith the Content object's parent ComplexTimelineObject. Content regions\nmay be expanded, contracted, or minimized. When expanded, the full\npreview image is visible, and the widget is expanded to maximum height\nso that the keyframe editor can be used. When contracted, only the\npreview image is visible. When minimized, the content region is\ncompletely hidden.\nOverrides make_content_image to create an audio waveform from audio\nstream data.\nOverrides make_content_image to create a thumbnail sequence.\nSimilar to a handle, but can be the selected, which implies that it\ncontains a reference to a core object.\nThis file contains the ScaleRuler class, a zoomable timeline ruler. It\nshould share the same gtk.Adjustment objects for both zooming and\nhorizontal scrolling.\n\nmulti-track editing\nmulti-layer editing*\nmultiple selection\nnoun-verb interaction\ndirect manipulation\nedge snapping\nmultiple-level undo/redo support\n\n\nutil.py\ncomplexinterface.py\ncomplextimeline.py\nruler.py\n\n\nSelectable\nDraggable\nSelectableDraggable\nMagnetic\n\n\nHistory\nComplexTimelineObject\n\nComplexTimelineFile\n\n\nContent\n\nAudioContent\nVideoContent\n\n\nHandle\nEditMarker\nComplexTrack\nComplexTimelineCanvas\nComplexTimelineWidget\n\n\nComplexTimelineFile\n\n\nAudioContent\nVideoContent\n\n\nThe smart group keeps track of its own position: Setting the x or y\nproperties on a smartgroup will cause all the group's children to\nmove accordingly.\nThe smart group keeps track of its size: If any of the group's\nchildren change size or position, the group recomputes its width and\nheight properties.\n\n\nwidth(item)\nheight(item)\nleft(item)\nright(item)\ntop(item)\nbottom(item)\ncenter(item)\n\n\nevent_coords(canvas, event)\n\n\npos(item)\nset_pos(item, pos), where pos is a tuple (x, y)\nsize(item)\nset_size(item, size), where size is a tuple (width, height)\n\n\nmanage_selection(canvas, changed_cb)\nmake_selectable(canvas, item)\nmake_dragable(canvas, item, start_cb, transform, end_cb,\nmoved_cb)\n\n\nmanage_selection(), activates internal selection management,\ndeprecates top-level function with same name\nmake_selectable(), activates selection management on a given\nobject, deprecates top-level function with same name.\nmake_selection_dragable(),\n\n\ndragStart -- a hook which is called to notify the object that\ndragging is about to begin\ndragEnd -- a hook which is called to notify the object that dragging\nhas ended\ndragMotion -- a hook which is called to notify the object that its\nposition should be updated.\n\n\ncore_object\n\n\n(absract) selected -- notifies the object it has been selected\n(absract) deselected -- notifies the object it has been deselected\nselect -- places this item in the current selection\ndeselect -- removes this item from the current selection\n(abstract) delete -- removes the core object from application data\nstructures\n(abstract) copy -- places a representation of the core object into\nthe application clipboard\n@classmethod getSelected -- returns a list of all selected\nselectable objects\n@classmethod getSelectedCoreObjects -- returns the pitivi core\nobject for every object that has been selected\n@classmethod deleteSelected -- deletes all selected objects\n\n\ndragStart -- relays dragStart message to all other selected\nSelectableDraggable objects\ndragEnd -- relays dragEnd message to all other selected\nSelectableDraggable objects\ndragMove -- relays dragmove message to all other selected\nSelectableDraggable objects\n(abstract) setPos -- implemented by derived objects, sets the\nposition of the core object represented by this object\n@classmethod selectedDragStart\n@classmethod selectedDragEnd\n@classmethod selectedDragMove\n\n\nflags -- when the control point is magnetic to the cursor, values\nare RESIZE, MOVE, RAZOR, COMMAND, ALL\n\n\nRESIZE -- control point is magnetic during resize operations\nMOVE -- control point is magnetic during drag operations\nRAZOR -- control point is magnetic to razor tool, or during trimming\nCOMMAND -- control point can be the input to a command which\noperates on current selection\nALL -- equal to RESIZE | MOVE | RAZOR | COMMAND\n\n\nsetTime -- update this magnet's time value\n@classmethod snapTime(time, flags) -- snap the input time to the\nnearest magnet according to flags\n@classmethod snapObj(start, duration, flags) -- snap start or end\ntime to the nearest magnet, according to flags)\n\n\nundo_actions -- stack of (function, data, inverse_function,\ninverse_data) tuples\nredo_actions -- stack of (function, data, inverse_function,\ninverse_data) tuples\n\n\nundoLast -- pop the top of the undo stack, push onto the redo stack\nand execute the inverse operation\nredoLast -- pop the redo stack, push the undo stack, and execute the\nnon-inverse operation\npushAction -- add a new tuple to the top of the history stack.\npeek -- return the top of the undo stack\npoke -- update the top of the undo stack in place\npop -- pop from the undo stack without performing any action or\npushing the redo stack (for example, to clear a canceled operation\nfrom the undo stack)\nclear -- clears the undo/redo stack\n\n\ndeleteSelected()\ncopySelected()\nmoveSelected()\nclearSelection()\nselectBeforeCurrent()\nselectAfterCurrent()\n\n\ncopySelected()\ndeleteSelected()\nmoveSelected()\nlinkSelected()\nunlinkSelected()\ncollapseSelected()\n\n\nactivateRazor()\ndeactivateRazor()\n\n\nTime is represented by horizontal position, in proportion to the\ncurrent zoom ratio\nPriority is represented by vertical position, with the top of the\ncanvas representing the highest priority.\n\n\nsource-added\nsource-removed\neffect-added\neffect-removed\ntransition-added\ntransition-removed\n\n\nwidth\nheight\nactive_color\nnormal_color\nmotion_callback\ncursor\n\n\n__init__ -- sets up initial properties, and stores the\nmotion_callback\ndragBegin -- sets item's color to the active color\ndragEnd -- sets item to the the normal color, updates magnet\ntimestamp\ndragMotion -- calls the motion_callback, after performing some\ntransformations\n\n\nbackground -- background rectangle\ncoreobject -- the core PiTiVi object which this timelineobject\nrepresents\ncontent -- Content object\ninpoint -- Handle, representing the in point of the source\noutpoint -- Handle, representing the out point of the source\n\n\ndragMotion -- calls setStartPoint, Magnetic.snapTime(), and\nselectable.dragMotion() to adjust the object's position.\n(private) startDurationChanged -- handler for the coreobject's\nstart-duration-changed signal\nsetStartPoint -- sets coreobject's start property\nsetInPoint -- callback given to inpoint as its motion callback,\nwhich sets coreobject's start/duration properties\nsetOutPoint -- callback given to outpoint as its motion callback\nwhich sets coreobject's duration property\n\n\nsetInPoint\nsetOutPoint\n\n\nwidth\nheight\nname\ncontent_image\nkeyframes\ncoreobject\n\n\nexpand()\ncontract()\nminimize()\nmake_content_image -- creates a generic image thumbnail.\n\n\nmake_content_image\n\n\nmake_content_image\n\n"});