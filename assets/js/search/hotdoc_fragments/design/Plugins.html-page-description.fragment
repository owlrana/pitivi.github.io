fragment_downloaded_cb({"url":"design/Plugins.html#page-description","fragment":"The PiTiVi plugin system will help keep the core to a minimum codebase\nrequired for normal editing. The plugins will add various kind of\nfunctionalities/interfaces for new features, special hardwares, online\nservices, ....\nThis is a list of use cases for plugins so we can figure out what are\nthe various categories of plugins we will need.\nHere we analyze some pluggable architecture implemented by other\nopensource projects in order to focus their strength/weak points in\nrelation to pitivi's needs. The list here does not pretend at all to be\nexaustive but is only meant to provide a cheap guided tour of the\nneighbourhood.\nDeluge is a bittorrent client written in python+gtk\n(http://www.deluge-torrent.org), it provides one of the most simple\nimplementation of a pluggable architecture:\nPlugins are stored in subdirectories of the ./plugin path. Each\nsubdirectory takes the name of the contained plugin. Each plugin should\nat least provide an __init__.py file which defines the custom\nnamespace and provides the access points for the plugin.\nInside the __init__.py are stored:\nThe plugin manager scans the plugin directory for new items and when a\nplugin is found, it imports the namespace into the list of plugins and\ncalls the deluge_init() function to initialize the plugin.\nThis implementation has the major advantage of being lightweight.\nIt does not create a class hierarchy for plugins: this can be both an\nadvantage and an handicap since changes in the common base plugin class\nwould potentially break plugin's compatibility but having a common\nancestor can simplify usual operation by defining them inside the\nancestor.\nIt is not possible to categorize plugins, even if a simple “category”\nfield inside the __init__.py would be enough.\nThis plugin architecture is useful for extending the application with\nfunctionality not considered in the core objects, since the plugin has\nfull control over the application and can thus extend any aspect of the\nhost.\nJokosher is an audio production software that uses python+gtk+gstreamer\n(http://www.jokosher.org)\nIts pluggable architecture places plugins into the ./extensions\ndirectory. Plugins can be stored as source .py files or packed into\npython eggs.\nExtension API are provided for inserting menu items inside the main\njokosher menu, as well as functions to control playback, instruments and\nto add new output formats.\nPlugin preferences are stored in the ./extension-config path, with one\nconfig file for each plugin named as the plugin itself. Preferences are\nserialized by pickle into a dictionary of objects; standard methods to\nstore and retrieve keys from the dictionary are available to the plugin\nwriter.\nThe plugin manager install/remove plugins taking care of possible\nconflicts, it also manages the loading/unloading/configuration processes\nfor each plugin, ensuring each plugin is loaded only once (plugins are\ntreated as singletons).\nEach plugin must contain:\nThis approach defines a clear set of API that the plugin can use as\npreferred way to interact with the main application, API are pushed into\nthe plugin when it is activated and a reference to them is usually kept\ninside the plugin though all its lifetime.\nAPI for UI integration allow to insert new menu items, leaving to the\nplugin the responsibility to remove the inserted items when it is\nunloaded. The same logic is applied when additional output formats are\nprovided by the plugin, those must be removed from available output\nformat by the plugin itself when it is deactivated.\nStrength points of the Jokosher approach are a well designed and\nlightweight plugin manager; the possibility to store plugins in python\neggs that simplifies a lot the deployment of new plugins; a clean set of\nAPI the plugin can use to interact with the host application; the\npossibility to add new output formats; the possibility to save plugin's\npreferences without having the plugin care about serialization\nprocedures.\nWeak points of this architecture are a limited UI integration because\nplugins which uses only the API can insert menu items only under the\n“plugin” submenu; the creation of a preferences file for each plugin\navailable could lead to a pollution of config files; leaving to plugins\nthe duty of removing UI enhancements they inserted could lead to waste\nof memory if the plugin writer does not make a good job, a defaulf\napproach for cleaning would be preferable.\nTrac is an enhanced wiki and issue tracking system for software\ndevelopment projects (http://trac.edgewall.org/), it has a consistent\npluggable architecture that it strikingly rensembles the one of the\nEclipse framework:\nThe main application exposes some entry points where plugin can plug\ninto. each entry point is characterized by a contract that both the\nplugin and the main application must subscrive in order to interact;\nthis contract takes the concrete form of an interface declared by the\nmain application and implemented by the plugin.\nEach plugin can implement multiple interfaces, in this way it extends\nmultiple aspects of the main application.\nEach entry point can be plugged by multiple plugins, thus the same\nfeature of the main application can be extended in multiple ways.\nPlugins can expose entry points themself, allowing them to be extended\nby other plugins.\nTrac plugins inherits from the “Component” class and are deployed as\npython eggs.\nThe whole application is designed to be modular and plugins can also be\ncreated to replace built-in components.\nTechnically, the most of the work is done in the core.py file which\ndeclares the following structures:\nTrac approach intruces a simple implementation for interfaces in python,\nan example code of how this architecture is used for creating plugins is\nreported in the following example (taken from Trac documentation):\nITodoObserver interface provides a todo_added() callback to trigger\nplugin's functionalities.\nThe class TodoList is declared as expandable by declaring an extension\npoint, used by plugins that implements the ITodoObserver interface.\nFinally an example plugin TodoPrinter is written that extends the\nTodoList by implementing the interface ITodoObserver via the\nimplements() function.\nSince version 3.0 the CMS engine Zope (http://www.zope.org) introduced a\nfull fledged interface implementation in python, as core system for its\npluggable architecture.\nIn python the concept of interfaces, intended as a formal way to define\nrelationships between items, does not yet exist; instead duck typing is\nthe generally utilized way, so if an object hasattr(foo, 'bar') then\nfoo.bar(), but this approach goes so far, since it is not possible to\ndetermine if an attribute is callable or has constrains to its possible\nvalues.\nIn fact plugin developers must rely over documentation to check what\nmethods their classes have to provide to implement a certain feature,\nand this approach is very prone to broke plugins compatibility if\ndocumentation is not kept perfectly synchronized with the code.\nZope interfaces are designed to be applied not only to classes, but also\nto modules, objects and functions, since they follow the golden rule\nthat “specification should make no assumption about implementation”;\nthis approach leaves complete freedom to the plugin developer to\norganize its code in the way it prefers, as long the intefrace\nrequirements are fulfilled; in this way duck typing gets formalized\nwithout adding a big overhead.\nInterfaces fully supports inheritance from other interfaces (with the\nsecurity check that children's methods conforms to ancestor's one if\noverridden), implementer of an interface hierarchy can limit the\nimplementation only to a certain child interface in the lineage; the\nstatus of interface implementer can be attached at runtime to items that\ndo not explicitly implemented the interface in their definition; as\nwell the implementer status can be removed from an item at runtime\n(useful for example in containers that implement an interface by\ndelegating implementation to contained objects).\nThe other big feature of Zope interfaces is that they can be used to\ncreate adapters in a very efficient way, providing also a centralized\nregistry for adapters.\nThese case studies exemplify two different approaches for extending the\nhost application:\nIn the first two cases (Deluge and Jokosher) the host application\nbasically defines a plugin manager that takes care of activating and\ndeactivating plugins; when activated, the plugin is allowed to access\nthe core objects and modify the application as it wants.\nThis approach has the advantage to leave complete freedom to plugins at\nthe cost of anarchy, since there isn't a standardized way for the plugin\nto interact with the host application. Jokosher tries to overcome this\nsituation by defining some API that can be optionally used by plugins to\naccomplish common tasks. The other big advantage is that plugins can be\ncreated to extend aspect of the application not considered originally by\nthe author to be extendable.\nIn the third case study (Trac), as opposite, plugins can only extend\nspecific aspects of the host application defined as extension points,\nwhose declare a clear contract the plugin must subscrive if it wants to\nextend the host application.\nThis approach enforces a neat definition of rights and duties for the\npartiecipants to the extension process at the cost of some freedom. In\nthis way plugins do not “put” their features into the application, but\n“offer” instead some extended features the application can use.\nThe last case study (Zope) further improves the concept of interfaces,\nadding the possibility to define attributes/constrains inside\ninterfaces, providing functions to check interface\nimplementation/definition, adding a complete facility to provide\nadapters; all this is done in the pythonic way of leaving the developer\nthe most freedom.\nThe main advantage of using interfaces over class inheritance is that\nthe former defines relationships between items and keeps the system\nhighly decoupled, while the latter constrains thee partecipants to a gree\nan “is a” relationship, thus creating strong coupling between classes.\nIn the light of needed use cases and analyzed case studies the following\nhybrid pluggable architecture is proposed for Pitivi.\nFrom here on, we will use the term “extension point” to define an aspect\nof the main application which can be extended by plugins. In respect to\nextension point we'll define “host” the component (usually pitivi but\nalso plugins can be extended) that exposes the extension point, and\n“extender” the component that plugs into the extension point in order to\nprovide additional features to the host component. Every extension point\nis characterized by a contract that both the parts must subscrive in\norder to interact.\nSince simple plugins may consist of a single python file, while complex\nplugins may comprise glade interfaces, code written in other languages,\ngraphics etc.. etc.. then plugins needs to be packed.\nA convenient method is to take advantage of python eggs\n(http://peak.telecommunity.com/DevCenter/PythonEggs) and create an .egg\nfile for each plugin. Eggs are similar to java's jar files, they make\nvery simple the shipping and installation of new plugins since all you\nneed is to drag the .egg file inside the ./plugins directory. Eggs also\nships a standard method for exposing plugin's entry points and\ndependencies, making easy to allow cooperation/subordination among\nplugins.\nwe can expect pitivi to be shipped with some default plugins available\nfor all the users and meant to be uninstalled by the system\nadministrator only; while it is also auspicable to let users install\ncustom plugins and encourage them in writing new ones.\nDefault plugins could be placed inside the pitivi installation path (i.e\n/usr/local/pitivi/plugins), these plugins are usually installed by the\nlinux distribution facility and only users with root privileges can\nmodify them directly.\nUser plugins could be placed inside the user home directory (i.e. in\n/home/my_user/.pitivi/plugins) and can be installed/deleted/modified by\nthe user.\nPitivi should check for both the locations when searching for available\nplugins, and should use the user home to store plugin configuration\nparameters (i.e /home/my_user/.pitivi/plugin-settings).\nThe relationship that exists between extension points and plugins is\nschematized in this cartoon:\n\nIn order to plug into the extension point the extender component must\nconform a protocol declared by the host component; this intefrace\nspecifies function signatures for the duties that host component is\nplanned to demand to plugin, like callbacks for occurred events, widgets\nto integrate into the user interface or implementation of common\noperations over new file formats.\nEach extension point should be able to keep a list of extenders plugged\nin, providing to the host component a convenient way for trasversing\nextenders.\nFor those plugin which wants to extend aspects of the application not\nexposing extension points, core objects of the host application can be\nmanipulated directly by the plugin writer. Since in python classes does\nnot encforce information hiding concepts, the plugin writer can easily\naccess them and inject the new features.\nIn order to allow the plugin this alternative extension approach, the\nplugin writer will insert new features when the plugin is activated by\nthe plugin manager, and provide a complete cleaning of plugged features\nwhen the plugin is deactivated.\nThe plugin manager is the orchestra director, its duties comprise:\nFor a generic plugin the user:\nFor an effect/transition the user:\nThe plugin manager backend:\nThe user:\nThe plugin manager backend:\nThe user:\nThe plugin manager:\nThe user:\nThe plugin manager:\nThe user:\nThe plugin manager:\nExtending the user interface could be achieved in basically two ways in\nGTK:\nThe first is writing custom code to integrate new widgets provided by\nthe plugin into the current user interface design.\nThe second way is taking advantage of the UImanager component provided\nby gtk, this facility allow the developer to define UI widgets as xml\nthen the UImanager can be told to merge the xml code into the existing\nGUI. Even thought this approach requires the plugin writer to learn\nUImanager xml syntax, the process clearly separate the UI creation part\nfrom the definition of actions triggered by the new UI piece, so it'll\nbe preferred to the former approach when possible.\nDespite of the type of widget integrated in the main user interface the\nfollowing interface definitions will provide methods with a “UI” suffix\nmeant to provide to the UImanager the xml code to integrate inside the\nmain user interface, and other methods with the suffix “Action” meant to\nprovide to the main application actions to bind to the main UI widgets.\nPlugins must conform to the following protocol if they want to extend\npitivi UI, in change pitivi is obliged to integrate the widgets provided\nby plugins in the way plugins define, with the freedom to choose when\nit's time to integrate them (usually when the main user interface is\nbuilt at application startup or when user choose to activate the\nplugin).\nPlacing a menu item or a tool button is the simplest way a plugin can\ninteract with the user, the following interfaces provide convenient ways\nfor the plugin to integrate widgets in the main user interface:\nClass IMenuProvider(Interface):\nThis kind of plugins provides items user can drag into the timeline such\nas videoclips, effects, transitions. Pitivi inserts a new tab in the\nsources notebook displayed in the top-left portion of the main window.\nPlugins that want to be source providers must implement the following\ninterface:\nClass ISourceProvider(Interface):\nNote on signals handling: the plugin may provide callbacks to observe\napplication signals, they're retrieved from the plugin with the\ngetCallbacks() method, the returned tuple is coonnected to host\napplication signals in the order specified by the plugin, and\ndisconnected in reverse order when the plugin is deactivated.\nRecording devices such as webcams, microphones but also unconventional\nitems like screencast share the same requirements to be used by Pitivi:\nThis kind of items represent an exception to the general concept of\nplugin, which are usually meant to be singletons by definition (only a\nsingle object for each plugin is created by the application), since\nthey're made to be applied more than one time over the timeline.\nEffects/Transitions are collected and exposed to the user as a list,\ngrouped into functional categories. This task will be accomplished by a\nspecialized SourceProvider plugin called Effect(Transition)Provider,\nexposing entry points where Effects can be inserted. The Provider takes\nalso care of creating a new effect object every time the user drags the\neffect to the timeline, thus implementing the Factory design pattern.\nEvery Effect object life-cycle starts in the moment the user drags it\ninto the timeline and ends when its is removed, during its lifetime the\nobject stores its custom preferencies in memory, while default\npreferences are stored in the same way of preferences of other plugins.\nDetailed discussion of Effects/Transitions architecture will be\ndiscussed in a separate design document.\nVarious links for inspiration...\n\nIstanbul controller : To be able to do screen-grabs that can then be\nedited within pitivi\nYouTube uploader : uploading projects to YouTube\n3rd party effects : provides higher-level effects re-using existing\nGStreamer elements. (optional) can provide a specific UI.\nUI-only plugins : provide a different user interface to manipulate\nthe timeline for specific tasks (compositing-specific view for\nexample)\nSpecific hardware integration\nimage sequence loader : So you can load a sequence of image files\nand use that as a source in the timeline.\nPut your ideas here...\n\n\nDescription fields (plugin's name, author, version and description)\ndeluge_init() function is called to initialize the plugin\nenable() function is called when the user enables the plugin\n\n\nsome descriptive fields identifying the name, description and\nversion\nstartup(api) function is called when the plugin is activated,\npassing the whole API set to the the plugin.\nshutdown() function is called when the plugin is deactivated, it\ntakes care of the cleanings.\n\n\nInterface class, defines the ancestor of all interfaces implemented\nby plugins using the implements() function\nExtensionPoint class, defines each single extension point slot,\ncharacterized by an Interface that every component who wants to plug\nmust conform.\nComponent class, defines the generical component boundled to an\nexinsing component manager\nComponentManager class, manages all the components available to the\napplication, switching them on/off and taking care each component is\na singleton.\n\n\nhttp://trac.edgewall.org/wiki/TracDev/ComponentArchitecture\nhttp://trac-hacks.org/wiki/EggCookingTutorial/BasicEggCooking\nhttp://live.gnome.org/Gedit/PythonPluginHowTo\nhttp://jokosher.python-hosting.com/wiki/ExtensionSystem\nhttp://twistedmatrix.com/projects/core/documentation/howto/plugin.html\nhttp://termie.pbwiki.com/SprinklesPy\nhttp://docs.turbogears.org/1.0/TemplatePlugins\nhttp://www.zope.org\n\n\nhttp://www.eclipse.org/articles/Article-Plug-in-architecture/plugin_architecture.html\nhttp://www.codeproject.com/csharp/C__Plugin_Architecture.asp\nhttp://www.codeproject.com/dotnet/PluginManagerClassBrk.asp\nhttp://www.objectplanet.com/opinio/userguide/index.htm?page=plugin_architecture.html\nhttp://developer.mozilla.org/en/docs/Plugin_Architecture\nhttp://sync4jmozilla.sourceforge.net/Mozilla%20PIM%20Plugin%20Design%20Document.pdf\nhttp://www.gnome.org/projects/epiphany/documentation/extensions/\n\n"});