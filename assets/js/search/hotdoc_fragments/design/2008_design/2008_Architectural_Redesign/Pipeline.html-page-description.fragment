fragment_downloaded_cb({"url": "design/2008_design/2008_Architectural_Redesign/Pipeline.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"Pipeline.md\">\n<h1 id=\"2008-architectural-redesignpipeline\">2008 Architectural Redesign/Pipeline</h1>\n<p><img src=\"Pipeline-functional.png\" alt=\"Pipeline functional view\" title=\"Pipeline functional view\" id=\"pipeline-functional-view\"></p>\n<h1 id=\"functional-description\">Functional Description</h1>\n<p>A <strong>Pipeline</strong> is where all the media processing takes place in PiTiVi.</p>\n<p>In order to hide the complexity of the underlying GStreamer pipeline, we\nonly have to work with 3 concepts:</p>\n<ul>\n<li><strong>Producer</strong>(s), responsible for providing data streams and the\nassociated GStreamer elements</li>\n<li><strong>Consumer</strong>(s), responsible for consuming data streams and the\nassociated GStreamer elements</li>\n<li><strong>Action</strong>(s), which brings in the combination of:\n<ul>\n<li>Which Consumer(s) and Producer(s) to use, and how to link the\nassociated GStreamer elements</li>\n<li>What the overall Action is, useful for the UI to provide the\nadequate interface for each action</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"pipeline\">Pipeline</h2>\n<h3 id=\"properties\">Properties</h3>\n<ul>\n<li>Actions, the list of Actions currently being used in the pipeline</li>\n<li>Producers, the list of Producers being used</li>\n<li>Consumers, the list of Consumers being used</li>\n</ul>\n<h3 id=\"signals\">Signals</h3>\n<ul>\n<li><code>action-added</code>, a new Action was added to the pipeline</li>\n<li><code>action-removed</code>, an Action was removed to the pipeline</li>\n</ul>\n<h2 id=\"producer\">Producer</h2>\n<h3 id=\"properties1\">Properties</h3>\n<ul>\n<li>Factory, the ObjectFactory being controlled by this Producer</li>\n<li>Pipeline, the Pipeline in which this Producer is being used</li>\n</ul>\n<h3 id=\"class-properties\">Class Properties</h3>\n<ul>\n<li>CompatibleFactory, a list of ObjectFactory types this Producer can\nmanage</li>\n</ul>\n<h3 id=\"signals1\">Signals</h3>\n<ul>\n<li><code>factory-changed</code></li>\n</ul>\n<h2 id=\"consumer\">Consumer</h2>\n<h3 id=\"properties2\">Properties</h3>\n<ul>\n<li>Factory, the ObjectFactory being controlled by this Consumer</li>\n<li>Pipeline, the Pipeline in which this Consumer is being used</li>\n</ul>\n<h3 id=\"class-properties1\">Class Properties</h3>\n<ul>\n<li>CompatibleFactory, a list of ObjectFactory types this Consumer can\nmanage</li>\n</ul>\n<h3 id=\"signals2\">Signals</h3>\n<ul>\n<li><code>factory-changed</code></li>\n</ul>\n<h2 id=\"action\">Action</h2>\n<h3 id=\"properties3\">Properties</h3>\n<ul>\n<li>Pipeline, on which it is being used, or going to be used</li>\n<li>Producers, that this Action is controlling</li>\n<li>Consumers, that this Action is controlling</li>\n<li>State, whether it is activated or not</li>\n</ul>\n<h3 id=\"class-properties2\">Class Properties</h3>\n<ul>\n<li>CompatibleProducer, a list of Producer types this Action can handle</li>\n<li>CompatibleConsumer, a list of Consumer types this Action can handle</li>\n</ul>\n<h3 id=\"signals3\">Signals</h3>\n<ul>\n<li><code>state-changed</code></li>\n</ul>\n<h1 id=\"use-cases\">Use Cases</h1>\n<h2 id=\"viewing-a-file\">Viewing a File</h2>\n<p><img src=\"Pipeline-viewing-file.png\" alt=\"Example: Viewing a File\" title=\"Example: Viewing a File\" id=\"example-viewing-a-file\">{width=\"200\"}</p>\n<p>This is the simplest use-case for a Pipeline, which is viewing a File.</p>\n<p>As can be seen in the Schema, there is only one action (<strong>ViewAction</strong>)\nwhich connects a SourceProducer to a LocalSinksConsumer.</p>\n<h2 id=\"rendering-a-timeline\">Rendering a Timeline</h2>\n<p><img src=\"Pipeline-rendering-timeline.png\" alt=\"Example: Rendering a Timeline\" title=\"Example: Rendering a Timeline\" id=\"example-rendering-a-timeline\">{width=\"200\"}</p>\n<p>In this example, we are doing 2 actions at the same time:</p>\n<ul>\n<li><strong>View</strong>ing the Timeline and,</li>\n<li><strong>Render</strong>ing the Timeline.</li>\n</ul>\n<h3 id=\"setting-up-the-render\">Setting up the render</h3>\n<p>Supposing we already had our Timeline Pipeline (With the\nTimelineProducer, LocalSinksConsumer and ViewAction), we just had to:</p>\n<ul>\n<li>Create a 'RenderAction' with our existing TimelineProducer as that\naction's producer,</li>\n<li>Set that Action on the Timeline\n<ul>\n<li><strong>UI</strong>: We get notified of a new Action set on the Pipeline, we\nopen the adequate UI for that Action (if needed).</li>\n</ul>\n</li>\n<li>Configure the newly created 'LocalRenderConsumer' which is the\nConsumer to which our RenderAction is linked to.\n<ul>\n<li><strong>UI</strong>: The Render Timeline interface linked to our action has\naccess to the configured Consumer and can open the adequate\nConfiguration Widget for that Consumer.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"actually-rendering\">Actually Rendering</h3>\n<ul>\n<li>We <strong>activate</strong> the Action on the pipeline\n<ul>\n<li>The pipeline gets reconfigured with all activated actions</li>\n</ul>\n</li>\n<li>We set the pipeline to PLAYING</li>\n</ul>\n<h3 id=\"finish-rendering\">Finish rendering</h3>\n<p>When we are done rendering (because we got an EOS or such), we can then:</p>\n<ul>\n<li>Remove that Action from the Pipeline (which will deactivate the\naction first, resetting the pipeline internally at the same time)\n<ul>\n<li><strong>UI</strong>: We get notified an action has been removed, we close the\nrelated interface/widgets.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"relationship-with-gstreamer\">Relationship with GStreamer</h1>\n<p><img src=\"Pipeline-gstreamer-relationship.png\" alt=\"Relationship with GStreamer\" title=\"Relationship with GStreamer\" id=\"relationship-with-gstreamer1\">{width=\"200\"}</p>\n\n</div>\n\n\n        "});