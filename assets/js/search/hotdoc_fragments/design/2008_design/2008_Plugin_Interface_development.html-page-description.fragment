fragment_downloaded_cb({"url":"design/2008_design/2008_Plugin_Interface_development.html#page-description","fragment":"Pitivi's current interface, whist having a solid base is a little\nlackluster with regards to API compatibility and formality, I\n(--Gord 16:06, 4 August 2008 (BST)) am currently\ndeveloping a branch that aims to counter that.\nCurrent development is happening on a launchpad branch (simply for ease\nof development for me) located here:\nhttps://code.edge.launchpad.net/~gordallott/+junk/pitivi-plugininterface\npitivi-plugininterface\nA plugin needs to communicate in two ways, the main application needs to\nbe able to talk to plugin code (call methods and such) and plugin code\nneeds to be able to communicate back via some sort of API, currently\npitivi handles the first problem with zope interfaces which works\nnicely, the second problem is ignored, plugins must query pitivi's\ninternal code via pitivi.instance.PiTiVi which contains the programs\ninstance.\nThe problem with this direction is that any internal code changes will\nbreak plugin compatibility and further more it increases the difficulty\nof the casual user writing plugins as they are required to be intimately\nknowledgeable of pitivi's internal code.\nThe tried and tested solution to this problem is to develop a plugin\nAPI, the API will handle any communication from the plugin to pitivi by\nabstracting pitivi.instance.PiTiVi with a stable API. The plugin can\nthen make simple calls such as api.gui.add_menu_item(...) and be\nconfident that the API will not change from version to version.\nThe api has a slight problem in that it may be initialised before pitivi\nis ready to be modified, This is solved at the moment by 'locking' the\napi (via decorators for ease of use..) until the main pitivi codebase\nemits a 'ready' signal, the api will raise an InterfaceNotReadyError\nexception if its called before then\nThe current API uses epydoc for its documentation and is structured as\nfollows:\nThe current api simply requires that plugin.settings exists and\n(un)pickles that data to save/load settings, there is a problem there\nwith human readabity and maybe even security, also its not that kind to\nversion upgrades.\nThe current implementation is inspired by Django's model setup,\nessentially the plugin authors create a class, in that class are Fields\n(special pitivi python objects that can handle validation and such) that\ndescribe settings.\nfor example the Field for a setting that must be a single line string\nwould be\nAt the moment plugin.settings must be a\npitivi.pluginsettings.SettingsStore object, this object can then create\nxml data to store and retrieve the settings as needed.\na further example for the entire settings store is:\nThis is a list of the current fields available:\nThe current api only makes one consideration regarding configuration,\nthat is that the plugin class object must be IConfigurable zope\ninterface compatible, which essentially means must provide the\nconfigure() method - this requires plugins to create their own\nconfiguration dialogs and such, which is a pain for plugin developers\nand a pain for anyone that likes consistency in their applications To\nsolve this I am proposing an interface that will be able to take\nsettings defined by a plugin and turn that into a sensible gtk\nconfiguration dialog.\nThe current implementation is a mix-in object that replaces the\nconfigure() method with our own gui-builder code (plugin authors that\nneed more flexibility can create their own configure() method)\nthe gui-builder code simply parses the current settings object and is\nable to build a gui from the fields provided, for example it will\nprovide a text entry for CharField objects. what 'widget' is used to\ndraw each settings can be further customised by providing the setting\nwith a widget argument, for example:\nthis code will provide an input widget where the characters are starred\nout which is appropriate for a password field. plugins can even provide\ntheir own widgets by subclassing FieldWidget but this is absolutely not\nnessasserry\nthis will check to see if the current screen is composited and emit a\nwarning\nThe above example produces the following image\n\n\n\n\npitivi\n\n\nPluginInterface\n\n\ngui\n\n\nshow_gui(self, *args, **kwargs) shows or hides the\nmain application window depending on the value of\n'visible'\n\nadd_menu_item(self, *args, **kwargs) Adds a menu\nitem to the appropriate main window menu\n\nremove_menu_item(self, name) removes the given menu\nitem from the user interface\n\nremove_ui(self) removes all changes this instance of\nthe plugininterface has made to the user interface\n\n\n\nProject\n\nadd_source\n\n\n\n\n\n\n\n\n\nPluginInterface\n\n\ngui\n\n\nshow_gui(self, *args, **kwargs) shows or hides the\nmain application window depending on the value of\n'visible'\n\nadd_menu_item(self, *args, **kwargs) Adds a menu\nitem to the appropriate main window menu\n\nremove_menu_item(self, name) removes the given menu\nitem from the user interface\n\nremove_ui(self) removes all changes this instance of\nthe plugininterface has made to the user interface\n\n\n\nProject\n\nadd_source\n\n\n\n\n\n\n\ngui\n\n\nshow_gui(self, *args, **kwargs) shows or hides the\nmain application window depending on the value of\n'visible'\n\nadd_menu_item(self, *args, **kwargs) Adds a menu\nitem to the appropriate main window menu\n\nremove_menu_item(self, name) removes the given menu\nitem from the user interface\n\nremove_ui(self) removes all changes this instance of\nthe plugininterface has made to the user interface\n\n\n\nProject\n\nadd_source\n\n\n\n\n\nshow_gui(self, *args, **kwargs) shows or hides the\nmain application window depending on the value of\n'visible'\n\nadd_menu_item(self, *args, **kwargs) Adds a menu\nitem to the appropriate main window menu\n\nremove_menu_item(self, name) removes the given menu\nitem from the user interface\n\nremove_ui(self) removes all changes this instance of\nthe plugininterface has made to the user interface\n\n\nadd_source\n\n\nBooleanField\nCharField\nFloatField\nIntegerField\nTextField\nNullField\n\n"});