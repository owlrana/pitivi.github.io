fragment_downloaded_cb({"url": "design/2008_design/2008_Jog_and_Shuttle_controls_code_experiment.html#page-description", "fragment": "<div id=\"page-description\" data-hotdoc-source=\"2008_Jog_and_Shuttle_controls_code_experiment.md\">\n<h2 id=\"introduction\">Introduction</h2>\n<p><img src=\"Gst-demo_wx_player-warning.png\" alt=\"wxPython prototype seeker with warning about inaccurate codec and some (green) markers.\" title=\"wxPython prototype seeker with warning about inaccurate codec and some (green) markers.\" id=\"wxpython-prototype-seeker-with-warning-about-inaccurate-codec-and-some-green-markers\"></p>\n<p><img src=\"Gst-demo_wx_player-interval.png\" alt=\"wxPython prototype seeker with selected interval between in &amp; out point and visual mouseover effect on jog.\" title=\"wxPython prototype seeker with selected interval between in &amp; out point and visual mouseover effect on jog.\" id=\"wxpython-prototype-seeker-with-selected-interval-between-in-out-point-and-visual-mouseover-effect-on-jog\"></p>\n<p><img src=\"Schermafdruk-gst-seeker-gtk.png\" alt=\"pygtk prototype seeker with hscale for time ruler, shuttle and jog.\" title=\"pygtk prototype seeker with hscale for time ruler, shuttle and jog.\" id=\"pygtk-prototype-seeker-with-hscale-for-time-ruler-shuttle-and-jog\"></p>\n<p><img src=\"Schermafdruk-gst-seeker-gtk-1.png\" alt=\"pygtk prototype seeker with mouseover effect on blend entry and warning with information. There is 12% difference between seek and query time in this video.\" title=\"pygtk prototype seeker with mouseover effect on blend entry and warning with information. There is 12% difference between seek and query time in this video.\" id=\"pygtk-prototype-seeker-with-mouseover-effect-on-blend-entry-and-warning-with-information-there-is-12-difference-between-seek-and-query-time-in-this-video\"></p>\n<h3 id=\"about\">About</h3>\n<p>I have been developing pystreamer, a MVC framework for python and\ngstreamer. It provides amongst other things a prototype for better frame\nseeking with gstreamer, which can be a starting point for pitivi. (It is\nnot the purpose to put the whole library in pitivi, I will rewrite it\ncustomized for pitivi so it can be applied as a patch.) The prototype is\nan attempt to deliver the control that serious video editors want. As it\nhas just been developed, it might contain some rough edges still. I will\ndiscuss it following its MVC structure:</p>\n<p>Model (gstreamer) &amp;lt;-&amp;gt; Controller (pure python) &amp;lt;-&amp;gt; View\n(pygtk/wxpython)</p>\n<h3 id=\"source-code\">Source Code</h3>\n<p>You can grab the sources with bazaar:</p>\n<pre><code>bzr branch lp:pystreamer\n</code></pre>\n<p>You need both wxpython (sudo apt-get install python-wxgtk) as pygtk to\nexplore the demos at the full potential. You can start the demos by:</p>\n<pre><code>./gst-player-gtk uri\n./gst-player-wx uri\n./gst-seeker-wx uri\n./gst-seeker-gtk uri\n</code></pre>\n<p>uri is for example '<a href=\"file:///home/user/some\">file:///home/user/some</a> movie.ogg'</p>\n<p>== Model = Player (gstreamer) ==</p>\n<p>There are two important aspects of frame seeking:</p>\n<ul>\n<li>stability: if you seek to a certain position, it should always\nreturn the same frame</li>\n<li>precision: if the framerate is n frames as second, seeking should be\npossible to each of the n frames</li>\n</ul>\n<p>With the right codecs, gstreamer performs well, but with inaccurate\ncodecs gstreamer (playbin) will fail on these two issues.</p>\n<h3 id=\"frame-stability\">Frame Stability</h3>\n<h4 id=\"the-problem\">The Problem</h4>\n<p>With inaccurate codecs gstreamer behave badly:</p>\n<ol>\n<li>seek to position x with gst.SEEK_FLAG_ACCURATE</li>\n<li>wait until gstreamer has finished seeking</li>\n<li>query the position which is returned as y</li>\n</ol>\n<p>You would expect that x is equal to y, but gstreamer provides different\nvalues. This makes video editing impossible. (You can see this effect in\nTotem by seeking to the end of the movie with an inaccurate codec. You\nwon't go to the end of the movie, but playback resumes much earlier.)\nThe most simple solution is to disable frame seeking for inaccurate\ncodecs or to transcode it to a better codec.</p>\n<p>A better solution would be to find a solution which can guarantee\nstability for any video codec. After doing some experiments and tests I\nfound out that:</p>\n<ul>\n<li>gstreamer always returns the same y for the same x. So it should be\npossible to find a method so that y = f(x).</li>\n<li>x is always bigger than y, so in order to go the last frame we have\nto seek past the duration of the movie. So the seek timeline is\nlonger than the query timeline.</li>\n</ul>\n<p>Based on these two observations, we need an algorithm which does the\nfollowing:</p>\n<ol>\n<li>x is corrected to a later position c</li>\n<li>c is seeked</li>\n<li>when seeking is finished, query the position which returns the same\nx</li>\n</ol>\n<h4 id=\"the-solution\">The Solution</h4>\n<p>So how can we correct x into z? We need to find the reverse method of f,\nlet's call it i. This means that x=f(z) and z=i(x). I first thought it\nmight be just a linear function, but that was not the case. So I\ndeveloped a frame correction algorithm which uses linear interpolation\nbetween known values of (x,f(x)) to predict (x,i(x)) or (x, z). You can\nfind the source code of this in the\npystreamer/player/frameMixin/Mixin.seek method. I've tested it with a\ncouple of videos with really bad codecs and it always seems to succeed.\nAs pitivi will be used by all kinds of end users, it is nice that they\ndon't have to worry about codecs or transcode it first in another codec.</p>\n<p>The algorithm knows after two seeks if the codec is accurate or not. If\nit is accurate, it will show a succes icon and the correction algorithm\ndisables itself. If it is incorrect, it will calculate and show a\nwarning sign. By clicking on the warning icon, you can optionally show\nthe incorrectness. The incorrectness is the average difference between\nseeked and queried positions in percent.</p>\n<p>Of course it makes seeking a bit more slow for inaccurate codecs, but\nthe speed remains acceptable. Moreover for video editing, frame\nstability/precision is more important than speed. (I guess because\ngstreamer is mainly used in media players not editors, speed was\nprioritized rather than precision.)</p>\n<h3 id=\"frame-precision\">Frame Precision</h3>\n<p>Unfortunately AFAIK there is nothing to do about this. The only option\nis here transcode the video to a better codec. However I found out that\neven with bad codecs it is possible to extract some frames out of a\nsecond instead of all of them. Probably if you work with bad codecs,\nthat should be ok.</p>\n<h2 id=\"controller\">Controller</h2>\n<p>The controller mimics the gobject signal system. Both the Player and the\nView are based on pystreamer/controller/controller_object.base which\nallows them to emit signals, which are processed by the controller to\nlink the two. The controller is 100% python and does not depend on gst,\ngobject, wxpython, pygtk, ...</p>\n<h2 id=\"view\">View</h2>\n<h3 id=\"features\">Features</h3>\n<p>The view supports many features, which might be interesting for pitivi:</p>\n<ul>\n<li>set in &amp; out point</li>\n<li>markers</li>\n<li>shuttle seeking</li>\n<li>jog seeking</li>\n<li>buttons for frame navigation (go to or play between in/out point, go\nto previous/next frame, go to previous/next marker)</li>\n<li>support for light and dark themes</li>\n<li>special button icons for video editing (svg sources are included)</li>\n</ul>\n<h3 id=\"base\">Base</h3>\n<p>The view code which is independent of the toolkit is in pystreamer/view.\nIt uses some ui_* methods which are overriden by specific toolkit\nmethods. The events are buffered with timer threads so that the UI stays\nas responsive as possible. The timer thread will not send seek events\nfor every user event, but rather keep track and only request a next seek\nwhen the previous one was finished.</p>\n<h3 id=\"wxpython\">wxPython</h3>\n<p>The wxPython prototype is quite complete. It provides three custom\ncontrols. The screenshots are working code, not just mock-ups.</p>\n<h4 id=\"blended-text\">Blended Text</h4>\n<ul>\n<li>pystreamer/view/uiWx/lib/BlendedTextCtrl.py</li>\n<li>this is rather semi-custom as it is a native control which has been\nextendend</li>\n<li>it looks like a StaticTextCtrl (label) but with a mouse over it\nlooks like a TextCtrl (entry)</li>\n<li>this is to avoid clutter and to make the view widget more quiet</li>\n<li>it is used for the current time, the in and out point.</li>\n</ul>\n<h4 id=\"timeline-ruler\">Timeline Ruler</h4>\n<ul>\n<li>pystreamer/view/uiWx/TimeRulerCtrl.py</li>\n<li>custom control</li>\n<li>this provides a timeline which shows the duration of the clip</li>\n<li>it uses native icons for the cursor and for the markers</li>\n<li>it shows visual feedback of selected interval between in &amp; out point</li>\n<li>intelligent algorithm for showing time labels</li>\n</ul>\n<h4 id=\"jog-control\">Jog Control</h4>\n<ul>\n<li>pystreamer/view/uiWx/lib/JogCtrl.py</li>\n<li>custom control</li>\n<li>supports disabled look</li>\n<li>suppors native colour highlight on mouseover</li>\n<li>very polished look</li>\n<li>support for dragging and mousewheel scrolling</li>\n<li>one pixel = one frame (So dragging the mouse 25 pixels, will seek to\n25 frames away.)</li>\n<li>different methods for dragging and scrolling to give the best user\nexperience</li>\n</ul>\n<h3 id=\"pygtk\">pyGtk</h3>\n<p>The pygtk prototype is less complete in custom controls, but is equally\nfunctional.</p>\n<h4 id=\"screenshots\">Screenshots</h4>\n<h4 id=\"blended-text1\">Blended Text</h4>\n<ul>\n<li>pystreamer/view/uiGtk/lib/BlendEntry.py</li>\n<li>this is rather semi-custom as it is a native control which has been\nextendend</li>\n<li>it looks like a gtk.Label but with a mouse over it looks like a\ngtk.Entry, what it really is</li>\n<li>see also blended text of wxpython</li>\n</ul>\n<h4 id=\"timeline-ruler1\">Timeline Ruler</h4>\n<ul>\n<li>pystreamer/view/uiGtk/HScaleRuler.py</li>\n<li>just a gtk.HScale, so less accurate</li>\n<li>no in &amp; outpoint interval feedback</li>\n<li>no markers</li>\n<li>todo: write a custom control for this</li>\n</ul>\n<h4 id=\"jog-control1\">Jog Control</h4>\n<ul>\n<li>pystreamer/view/uiGtk/HScaleJog.py</li>\n<li>just a gtk.HScale</li>\n<li>modified behaviour to make the hscale behave as a jog (eg remains\nsensitive outside its area)</li>\n<li>see also jog control of wxpython</li>\n<li>todo: write a custom control for this</li>\n</ul>\n<h2 id=\"known-issues\">Known issues</h2>\n<ul>\n<li>with inaccurate codecs: sometimes after a difficult seek, the player\ndoesn't start again. A solution could be that seeking pauses the\nvideo, but it would be nice if it doesn't have to.</li>\n<li>pygtk: I am wondering how I can determine if a dark or normal theme\nis used. I am only able to retrieve the right background color after\nthe window has been realized with window.get_style().bg But how can\nI know this before?</li>\n<li>pygtk: How to hide optionally some widgets such as the warning\ninformation?</li>\n<li>keyboard bindings need to be added</li>\n</ul>\n\n</div>\n\n\n\t"});