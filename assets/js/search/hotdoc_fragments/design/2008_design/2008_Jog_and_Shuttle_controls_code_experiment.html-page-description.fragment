fragment_downloaded_cb({"url": "design/2008_design/2008_Jog_and_Shuttle_controls_code_experiment.html#page-description", "fragment": "\n\n\n\nI have been developing pystreamer a MVC framework for python and gstreamer. It provides amongst other things a prototype for better frame seeking with gstreamer which can be a starting point for pitivi. It is not the purpose to put the whole library in pitivi I will rewrite it customized for pitivi so it can be applied as a patch. The prototype is an attempt to deliver the control that serious video editors want. As it has just been developed it might contain some rough edges still. I will discuss it following its MVC structure \nModel gstreamer Controller pure python View pygtk wxpython \nYou can grab the sources with bazaar \nYou need both wxpython sudo apt get install python wxgtk as pygtk to explore the demos at the full potential. You can start the demos by \nuri is for example file home user some movie.ogg \nModel Player gstreamer \nThere are two important aspects of frame seeking \nWith the right codecs gstreamer performs well but with inaccurate codecs gstreamer playbin will fail on these two issues. \nWith inaccurate codecs gstreamer behave badly \nYou would expect that x is equal to y but gstreamer provides different values. This makes video editing impossible. You can see this effect in Totem by seeking to the end of the movie with an inaccurate codec. You won t go to the end of the movie but playback resumes much earlier. The most simple solution is to disable frame seeking for inaccurate codecs or to transcode it to a better codec. \nA better solution would be to find a solution which can guarantee stability for any video codec. After doing some experiments and tests I found out that \nBased on these two observations we need an algorithm which does the following \nSo how can we correct x into z We need to find the reverse method of f let s call it i. This means that x f z and z i x I first thought it might be just a linear function but that was not the case. So I developed a frame correction algorithm which uses linear interpolation between known values of x f x to predict x i x or x z You can find the source code of this in the pystreamer player frameMixin Mixin.seek method. I ve tested it with a couple of videos with really bad codecs and it always seems to succeed. As pitivi will be used by all kinds of end users it is nice that they don t have to worry about codecs or transcode it first in another codec. \nThe algorithm knows after two seeks if the codec is accurate or not. If it is accurate it will show a success icon and the correction algorithm disables itself. If it is incorrect it will calculate and show a warning sign. By clicking on the warning icon you can optionally show the incorrectness. The incorrectness is the average difference between seeked and queried positions in percent. \nOf course it makes seeking a bit more slow for inaccurate codecs but the speed remains acceptable. Moreover for video editing frame stability precision is more important than speed. I guess because gstreamer is mainly used in media players not editors speed was prioritized rather than precision. \nUnfortunately AFAIK there is nothing to do about this. The only option is here transcode the video to a better codec. However I found out that even with bad codecs it is possible to extract some frames out of a second instead of all of them. Probably if you work with bad codecs that should be ok. \nThe controller mimics the gobject signal system. Both the Player and the View are based on pystreamer controller controller_object.base which allows them to emit signals which are processed by the controller to link the two. The controller is python and does not depend on gst gobject wxpython pygtk \nThe view supports many features which might be interesting for pitivi \nThe view code which is independent of the toolkit is in pystreamer view. It uses some ui_ methods which are overridden by specific toolkit methods. The events are buffered with timer threads so that the UI stays as responsive as possible. The timer thread will not send seek events for every user event but rather keep track and only request a next seek when the previous one was finished. \nThe wxPython prototype is quite complete. It provides three custom controls. The screenshots are working code not just mock ups. \nThe pygtk prototype is less complete in custom controls but is equally functional. \n"});