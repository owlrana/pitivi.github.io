fragment_downloaded_cb({"url":"design/2008_design/2008_Jog_and_Shuttle_controls_code_experiment.html#page-description","fragment":"\n\n\n\nI have been developing pystreamer, a MVC framework for python and\ngstreamer. It provides amongst other things a prototype for better frame\nseeking with gstreamer, which can be a starting point for pitivi. (It is\nnot the purpose to put the whole library in pitivi, I will rewrite it\ncustomized for pitivi so it can be applied as a patch.) The prototype is\nan attempt to deliver the control that serious video editors want. As it\nhas just been developed, it might contain some rough edges still. I will\ndiscuss it following its MVC structure:\nModel (gstreamer) <-> Controller (pure python) <-> View\n(pygtk/wxpython)\nYou can grab the sources with bazaar:\nYou need both wxpython (sudo apt-get install python-wxgtk) as pygtk to\nexplore the demos at the full potential. You can start the demos by:\nuri is for example file:///home/user/some movie.ogg\n== Model = Player (gstreamer) ==\nThere are two important aspects of frame seeking:\nWith the right codecs, gstreamer performs well, but with inaccurate\ncodecs gstreamer (playbin) will fail on these two issues.\nWith inaccurate codecs gstreamer behave badly:\nYou would expect that x is equal to y, but gstreamer provides different\nvalues. This makes video editing impossible. (You can see this effect in\nTotem by seeking to the end of the movie with an inaccurate codec. You\nwon't go to the end of the movie, but playback resumes much earlier.)\nThe most simple solution is to disable frame seeking for inaccurate\ncodecs or to transcode it to a better codec.\nA better solution would be to find a solution which can guarantee\nstability for any video codec. After doing some experiments and tests I\nfound out that:\nBased on these two observations, we need an algorithm which does the\nfollowing:\nSo how can we correct x into z? We need to find the reverse method of f,\nlet's call it i. This means that x=f(z) and z=i(x). I first thought it\nmight be just a linear function, but that was not the case. So I\ndeveloped a frame correction algorithm which uses linear interpolation\nbetween known values of (x,f(x)) to predict (x,i(x)) or (x, z). You can\nfind the source code of this in the\npystreamer/player/frameMixin/Mixin.seek method. I've tested it with a\ncouple of videos with really bad codecs and it always seems to succeed.\nAs pitivi will be used by all kinds of end users, it is nice that they\ndon't have to worry about codecs or transcode it first in another codec.\nThe algorithm knows after two seeks if the codec is accurate or not. If\nit is accurate, it will show a success icon and the correction algorithm\ndisables itself. If it is incorrect, it will calculate and show a\nwarning sign. By clicking on the warning icon, you can optionally show\nthe incorrectness. The incorrectness is the average difference between\nseeked and queried positions in percent.\nOf course it makes seeking a bit more slow for inaccurate codecs, but\nthe speed remains acceptable. Moreover for video editing, frame\nstability/precision is more important than speed. (I guess because\ngstreamer is mainly used in media players not editors, speed was\nprioritized rather than precision.)\nUnfortunately AFAIK there is nothing to do about this. The only option\nis here transcode the video to a better codec. However I found out that\neven with bad codecs it is possible to extract some frames out of a\nsecond instead of all of them. Probably if you work with bad codecs,\nthat should be ok.\nThe controller mimics the gobject signal system. Both the Player and the\nView are based on pystreamer/controller/controller_object.base which\nallows them to emit signals, which are processed by the controller to\nlink the two. The controller is 100% python and does not depend on gst,\ngobject, wxpython, pygtk, ...\nThe view supports many features, which might be interesting for pitivi:\nThe view code which is independent of the toolkit is in pystreamer/view.\nIt uses some ui_* methods which are overridden by specific toolkit\nmethods. The events are buffered with timer threads so that the UI stays\nas responsive as possible. The timer thread will not send seek events\nfor every user event, but rather keep track and only request a next seek\nwhen the previous one was finished.\nThe wxPython prototype is quite complete. It provides three custom\ncontrols. The screenshots are working code, not just mock-ups.\nThe pygtk prototype is less complete in custom controls, but is equally\nfunctional.\n\nstability: if you seek to a certain position, it should always\nreturn the same frame\nprecision: if the framerate is n frames as second, seeking should be\npossible to each of the n frames\n\n\ngstreamer always returns the same y for the same x. So it should be\npossible to find a method so that y = f(x).\nx is always bigger than y, so in order to go the last frame we have\nto seek past the duration of the movie. So the seek timeline is\nlonger than the query timeline.\n\n\nset in & out point\nmarkers\nshuttle seeking\njog seeking\nbuttons for frame navigation (go to or play between in/out point, go\nto previous/next frame, go to previous/next marker)\nsupport for light and dark themes\nspecial button icons for video editing (svg sources are included)\n\n\npystreamer/view/uiWx/lib/BlendedTextCtrl.py\nthis is rather semi-custom as it is a native control which has been\nextendend\nit looks like a StaticTextCtrl (label) but with a mouse over it\nlooks like a TextCtrl (entry)\nthis is to avoid clutter and to make the view widget more quiet\nit is used for the current time, the in and out point.\n\n\npystreamer/view/uiWx/TimeRulerCtrl.py\ncustom control\nthis provides a timeline which shows the duration of the clip\nit uses native icons for the cursor and for the markers\nit shows visual feedback of selected interval between in & out point\nintelligent algorithm for showing time labels\n\n\npystreamer/view/uiWx/lib/JogCtrl.py\ncustom control\nsupports disabled look\nsuppors native colour highlight on mouseover\nvery polished look\nsupport for dragging and mousewheel scrolling\none pixel = one frame (So dragging the mouse 25 pixels, will seek to\n25 frames away.)\ndifferent methods for dragging and scrolling to give the best user\nexperience\n\n\npystreamer/view/uiGtk/lib/BlendEntry.py\nthis is rather semi-custom as it is a native control which has been\nextendend\nit looks like a gtk.Label but with a mouse over it looks like a\ngtk.Entry, what it really is\nsee also blended text of wxpython\n\n\npystreamer/view/uiGtk/HScaleRuler.py\njust a gtk.HScale, so less accurate\nno in & outpoint interval feedback\nno markers\ntodo: write a custom control for this\n\n\npystreamer/view/uiGtk/HScaleJog.py\njust a gtk.HScale\nmodified behaviour to make the hscale behave as a jog (eg remains\nsensitive outside its area)\nsee also jog control of wxpython\ntodo: write a custom control for this\n\n\nwith inaccurate codecs: sometimes after a difficult seek, the player\ndoesn't start again. A solution could be that seeking pauses the\nvideo, but it would be nice if it doesn't have to.\npygtk: I am wondering how I can determine if a dark or normal theme\nis used. I am only able to retrieve the right background color after\nthe window has been realized with window.get_style().bg But how can\nI know this before?\npygtk: How to hide optionally some widgets such as the warning\ninformation?\nkeyboard bindings need to be added\n\n"});